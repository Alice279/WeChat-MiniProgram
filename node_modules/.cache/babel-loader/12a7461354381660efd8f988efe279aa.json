{"ast":null,"code":"'use strict';\n\nimport BN from 'bn.js';\nconst ALPHABET = 'abcdefghjkmnprstuvwxyz0123456789'; // pre-compute lookup table\n\nconst SEPARATOR = ':';\nconst CSLEN = 8;\nconst ALPHABET_MAP = {};\n\nfor (let z = 0; z < ALPHABET.length; z++) {\n  const x = ALPHABET.charAt(z);\n\n  if (ALPHABET_MAP[x] !== undefined) {\n    throw new TypeError(x + ' is ambiguous');\n  }\n\n  ALPHABET_MAP[x] = z;\n}\n\nfunction polymodStep(pre) {\n  const b = pre.shrn(35);\n  const mask = new BN('07ffffffff', 16);\n  let v = pre.and(mask).shln(5);\n\n  if (b.and(new BN('1')).toNumber() > 0) {\n    v = v.xor(new BN('98f2bc8e61', 16));\n  }\n\n  if (b.and(new BN('2')).toNumber()) {\n    v = v.xor(new BN('79b76d99e2', 16));\n  }\n\n  if (b.and(new BN('4')).toNumber()) {\n    v = v.xor(new BN('f33e5fb3c4', 16));\n  }\n\n  if (b.and(new BN('8')).toNumber()) {\n    v = v.xor(new BN('ae2eabe2a8', 16));\n  }\n\n  if (b.and(new BN('16')).toNumber()) {\n    v = v.xor(new BN('1e4f43e470', 16));\n  }\n\n  return v;\n}\n\nfunction prefixChk(prefix) {\n  let chk = new BN('1');\n\n  for (let i = 0; i < prefix.length; ++i) {\n    const c = prefix.charCodeAt(i);\n    const mixwith = new BN('' + (c & 0x1f));\n    chk = polymodStep(chk).xor(mixwith);\n  }\n\n  chk = polymodStep(chk);\n  return chk;\n}\n\nexport function encode(prefix, words) {\n  // too long?\n  if (prefix.length + CSLEN + 1 + words.length > 90) {\n    throw new TypeError('Exceeds Base32 maximum length');\n  }\n\n  prefix = prefix.toLowerCase(); // determine chk mod\n\n  let chk = prefixChk(prefix);\n  let result = prefix + SEPARATOR;\n\n  for (let i = 0; i < words.length; ++i) {\n    const x = words[i];\n\n    if (x >>> 5 !== 0) {\n      throw new Error('Non 5-bit word');\n    }\n\n    chk = polymodStep(chk).xor(new BN(x, 16));\n    result += ALPHABET.charAt(x);\n  }\n\n  for (let i = 0; i < CSLEN; ++i) {\n    chk = polymodStep(chk);\n  }\n\n  chk = chk.xor(new BN('1'));\n\n  for (let i = 0; i < CSLEN; ++i) {\n    const pos = 5 * (CSLEN - 1 - i);\n    const v2 = chk.shrn(pos).and(new BN('1f', 16));\n    result += ALPHABET.charAt(v2.toString(10));\n  }\n\n  return result;\n}\nexport function decode(str) {\n  if (str.length < 8) {\n    throw new TypeError(str + ' too short');\n  }\n\n  if (str.length > 90) {\n    throw new TypeError(str + ' too long');\n  } // don't allow mixed case\n\n\n  const lowered = str.toLowerCase();\n  const uppered = str.toUpperCase();\n\n  if (str !== lowered && str !== uppered) {\n    throw new Error('Mixed-case string ' + str);\n  }\n\n  const split = lowered.lastIndexOf(SEPARATOR);\n\n  if (split === -1) {\n    throw new Error('No separator character for ' + lowered);\n  }\n\n  if (split === 0) {\n    throw new Error('Missing prefix for ' + lowered);\n  }\n\n  const prefix = lowered.slice(0, split);\n  const wordChars = lowered.slice(split + 1);\n\n  if (wordChars.length < 6) {\n    throw new Error('Data too short');\n  }\n\n  let chk = prefixChk(prefix);\n  const words = [];\n\n  for (let i = 0; i < wordChars.length; ++i) {\n    const c = wordChars.charAt(i);\n    const v = ALPHABET_MAP[c];\n\n    if (v === undefined) {\n      throw new Error('Unknown character ' + c);\n    }\n\n    chk = polymodStep(chk).xor(new BN('' + v)); // not in the checksum?\n\n    if (i + CSLEN >= wordChars.length) {\n      continue;\n    }\n\n    words.push(v);\n  }\n\n  if (chk.toString(10) !== '1') {\n    throw new Error('Invalid checksum for ' + lowered);\n  }\n\n  return {\n    prefix,\n    words\n  };\n}\n\nfunction convert(data, inBits, outBits, pad) {\n  let value = 0;\n  let bits = 0;\n  const maxV = (1 << outBits) - 1;\n  const result = [];\n\n  for (let i = 0; i < data.length; ++i) {\n    value = value << inBits | data[i];\n    bits += inBits;\n\n    while (bits >= outBits) {\n      bits -= outBits;\n      result.push(value >>> bits & maxV);\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push(value << outBits - bits & maxV);\n    }\n  } else {\n    if (bits >= inBits) {\n      throw new Error('Excess padding');\n    }\n\n    if (value << outBits - bits & maxV) {\n      throw new Error('Non-zero padding');\n    }\n  }\n\n  return result;\n}\n\nexport function toWords(bytes) {\n  return convert(bytes, 8, 5, true);\n}\nexport function fromWords(words) {\n  return convert(words, 5, 8, false);\n}","map":{"version":3,"sources":["/Users/alice/Documents/rigel/node_modules/@cfxjs/base32/index.js"],"names":["BN","ALPHABET","SEPARATOR","CSLEN","ALPHABET_MAP","z","length","x","charAt","undefined","TypeError","polymodStep","pre","b","shrn","mask","v","and","shln","toNumber","xor","prefixChk","prefix","chk","i","c","charCodeAt","mixwith","encode","words","toLowerCase","result","Error","pos","v2","toString","decode","str","lowered","uppered","toUpperCase","split","lastIndexOf","slice","wordChars","push","convert","data","inBits","outBits","pad","value","bits","maxV","toWords","bytes","fromWords"],"mappings":"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","sourcesContent":["'use strict'\nimport BN from 'bn.js'\n\nconst ALPHABET = 'abcdefghjkmnprstuvwxyz0123456789'\n\n// pre-compute lookup table\nconst SEPARATOR = ':'\nconst CSLEN = 8\nconst ALPHABET_MAP = {}\nfor (let z = 0; z < ALPHABET.length; z++) {\n  const x = ALPHABET.charAt(z)\n  if (ALPHABET_MAP[x] !== undefined) {\n    throw new TypeError(x + ' is ambiguous')\n  }\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep(pre) {\n  const b = pre.shrn(35)\n  const mask = new BN('07ffffffff', 16)\n\n  let v = pre.and(mask).shln(5)\n\n  if (b.and(new BN('1')).toNumber() > 0) {\n    v = v.xor(new BN('98f2bc8e61', 16))\n  }\n  if (b.and(new BN('2')).toNumber()) {\n    v = v.xor(new BN('79b76d99e2', 16))\n  }\n  if (b.and(new BN('4')).toNumber()) {\n    v = v.xor(new BN('f33e5fb3c4', 16))\n  }\n  if (b.and(new BN('8')).toNumber()) {\n    v = v.xor(new BN('ae2eabe2a8', 16))\n  }\n  if (b.and(new BN('16')).toNumber()) {\n    v = v.xor(new BN('1e4f43e470', 16))\n  }\n\n  return v\n}\n\nfunction prefixChk(prefix) {\n  let chk = new BN('1')\n  for (let i = 0; i < prefix.length; ++i) {\n    const c = prefix.charCodeAt(i)\n\n    const mixwith = new BN('' + (c & 0x1f))\n    chk = polymodStep(chk).xor(mixwith)\n  }\n\n  chk = polymodStep(chk)\n  return chk\n}\n\nexport function encode(prefix, words) {\n  // too long?\n  if (prefix.length + CSLEN + 1 + words.length > 90) {\n    throw new TypeError('Exceeds Base32 maximum length')\n  }\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  let chk = prefixChk(prefix)\n  let result = prefix + SEPARATOR\n  for (let i = 0; i < words.length; ++i) {\n    const x = words[i]\n    if (x >>> 5 !== 0) {\n      throw new Error('Non 5-bit word')\n    }\n\n    chk = polymodStep(chk).xor(new BN(x, 16))\n    result += ALPHABET.charAt(x)\n  }\n\n  for (let i = 0; i < CSLEN; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk = chk.xor(new BN('1'))\n  for (let i = 0; i < CSLEN; ++i) {\n    const pos = 5 * (CSLEN - 1 - i)\n    const v2 = chk.shrn(pos).and(new BN('1f', 16))\n    result += ALPHABET.charAt(v2.toString(10))\n  }\n\n  return result\n}\n\nexport function decode(str) {\n  if (str.length < 8) {\n    throw new TypeError(str + ' too short')\n  }\n  if (str.length > 90) {\n    throw new TypeError(str + ' too long')\n  }\n\n  // don't allow mixed case\n  const lowered = str.toLowerCase()\n  const uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) {\n    throw new Error('Mixed-case string ' + str)\n  }\n\n  const split = lowered.lastIndexOf(SEPARATOR)\n  if (split === -1) {\n    throw new Error('No separator character for ' + lowered)\n  }\n\n  if (split === 0) {\n    throw new Error('Missing prefix for ' + lowered)\n  }\n\n  const prefix = lowered.slice(0, split)\n  const wordChars = lowered.slice(split + 1)\n  if (wordChars.length < 6) {\n    throw new Error('Data too short')\n  }\n\n  let chk = prefixChk(prefix)\n  const words = []\n  for (let i = 0; i < wordChars.length; ++i) {\n    const c = wordChars.charAt(i)\n    const v = ALPHABET_MAP[c]\n    if (v === undefined) {\n      throw new Error('Unknown character ' + c)\n    }\n\n    chk = polymodStep(chk).xor(new BN('' + v))\n    // not in the checksum?\n    if (i + CSLEN >= wordChars.length) {\n      continue\n    }\n    words.push(v)\n  }\n\n  if (chk.toString(10) !== '1') {\n    throw new Error('Invalid checksum for ' + lowered)\n  }\n\n  return {prefix, words}\n}\n\nfunction convert(data, inBits, outBits, pad) {\n  let value = 0\n  let bits = 0\n  const maxV = (1 << outBits) - 1\n\n  const result = []\n  for (let i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >>> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) {\n      throw new Error('Excess padding')\n    }\n    if ((value << (outBits - bits)) & maxV) {\n      throw new Error('Non-zero padding')\n    }\n  }\n\n  return result\n}\n\nexport function toWords(bytes) {\n  return convert(bytes, 8, 5, true)\n}\n\nexport function fromWords(words) {\n  return convert(words, 5, 8, false)\n}\n"]},"metadata":{},"sourceType":"module"}
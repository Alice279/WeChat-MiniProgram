{"ast":null,"code":"import { encode as encodeBase32, decode as decodeBase32, toWords, fromWords } from '@cfxjs/base32';\nimport { Buffer } from 'buffer';\nimport { randomHexAddress, randomAddressType } from '@cfxjs/account';\nimport { stripHexPrefix } from '@cfxjs/utils';\nconst VERSION_BYTE = 0;\nconst NET_ID_LIMIT = 0xffffffff;\n\nfunction encodeNetId(netId) {\n  if (!Number.isInteger(netId)) {\n    throw new Error('netId should be passed as an integer');\n  }\n\n  if (netId <= 0 || netId > NET_ID_LIMIT) {\n    throw new Error('netId should be passed as in range [1, 0xFFFFFFFF]');\n  }\n\n  switch (netId) {\n    case 1:\n      return 'cfxtest';\n\n    case 1029:\n      return 'cfx';\n\n    default:\n      return `net${netId}`;\n  }\n}\n\nfunction isValidNetId(netId) {\n  return /^([1-9]\\d*)$/.test(netId) && Number(netId) <= NET_ID_LIMIT;\n}\n\nfunction decodeNetId(payload) {\n  switch (payload) {\n    case 'cfxtest':\n      return 1;\n\n    case 'cfx':\n      return 1029;\n\n    default:\n      {\n        const prefix = payload.slice(0, 3);\n        const netId = payload.slice(3);\n\n        if (prefix !== 'net' || !isValidNetId(netId)) {\n          throw new Error(\"netId prefix should be passed by 'cfx', 'cfxtest' or 'net[n]' \");\n        }\n\n        if (Number(netId) === 1 || Number(netId) === 1029) {\n          throw new Error('net1 or net1029 are invalid');\n        }\n\n        return Number(netId);\n      }\n  }\n}\n\nfunction encodePayload(hexAddress) {\n  return Buffer.concat([Buffer.from([VERSION_BYTE]), hexAddress]);\n}\n\nfunction decodePayload(payload) {\n  if (payload[0] !== VERSION_BYTE) {\n    throw new Error('Can not recognize version byte');\n  }\n\n  return Buffer.from(payload.slice(1));\n}\n\nfunction getAddressType(hexAddress) {\n  if (hexAddress.length < 1) {\n    throw new Error('Empty payload in address');\n  }\n\n  switch (hexAddress[0] & 0xf0) {\n    case 0x10:\n      return 'user';\n\n    case 0x80:\n      return 'contract';\n\n    case 0x00:\n      for (const x of hexAddress) {\n        if (x !== 0x00) {\n          return 'builtin';\n        }\n      }\n\n      return 'null';\n\n    default:\n      throw new Error('hexAddress should start with 0x0, 0x1 or 0x8');\n  }\n}\n\nexport function encode(hexAddress, netId, verbose = false) {\n  if (!(hexAddress instanceof Buffer)) {\n    throw new Error('hexAddress should be passed as a Buffer');\n  }\n\n  if (hexAddress.length < 20) {\n    throw new Error('hexAddress should be at least 20 bytes');\n  }\n\n  const addressType = getAddressType(hexAddress);\n  let encodedAddress = encodeBase32(encodeNetId(netId), toWords(encodePayload(hexAddress)));\n\n  if (verbose) {\n    const [prefix, payload] = encodedAddress.split(':');\n    encodedAddress = [prefix, `type.${addressType}`, payload].join(':').toUpperCase();\n  }\n\n  return encodedAddress;\n}\nexport function decode(address) {\n  // don't allow mixed case\n  const lowered = address.toLowerCase();\n  const uppered = address.toUpperCase();\n\n  if (address !== lowered && address !== uppered) {\n    throw new Error('Mixed-case address ' + address);\n  }\n\n  const splits = address.split(':');\n  let shouldHaveType = '';\n  let reducedAddress = address;\n\n  if (splits.length === 3) {\n    shouldHaveType = splits[1];\n    reducedAddress = [splits[0], splits[2]].join(':');\n  }\n\n  const result = decodeBase32(reducedAddress);\n  const data = fromWords(result.words);\n\n  if (data.length < 1) {\n    throw new Error('Empty payload in address');\n  }\n\n  const returnValue = {\n    hexAddress: decodePayload(data),\n    netId: decodeNetId(result.prefix),\n    type: getAddressType(decodePayload(data))\n  };\n\n  if (shouldHaveType !== '' && `type.${returnValue.type}` !== shouldHaveType.toLowerCase()) {\n    throw new Error(\"Type of address doesn't match\");\n  }\n\n  return returnValue;\n}\nexport function validateBase32Address(address, ...args) {\n  let netId, type, decoded;\n  let valid = false;\n\n  if (args[0] !== undefined && args[0] !== null) {\n    if (Number.isSafeInteger(args[0])) netId = args[0];else if (typeof args[0] === 'string') type = args[0];else throw new Error('Invalid type or networkId, type must be string, networkId must be number');\n\n    if (args[1] !== undefined && args[1] !== null) {\n      if (Number.isSafeInteger(args[1])) netId = args[1];else if (typeof args[1] === 'string') type = args[1];else throw new Error('Invalid type or networkId, type must be string, networkId must be number');\n    }\n  }\n\n  try {\n    decoded = decode(address);\n    valid = true;\n    if (netId !== undefined && netId !== decoded.netId) valid = false;\n    if (type !== undefined && type !== decoded.type) valid = false;\n  } catch (err) {\n    valid = false;\n  }\n\n  return valid;\n}\nexport const randomBase32Address = (...args) => {\n  let netId, type;\n\n  if (args[0] !== undefined && args[0] !== null) {\n    if (Number.isSafeInteger(args[0])) netId = args[0];else if (typeof args[0] === 'string') type = args[0];else throw new Error('Invalid type or networkId, type must be string, networkId must be number');\n\n    if (args[1] !== undefined && args[1] !== null) {\n      if (Number.isSafeInteger(args[1])) netId = args[1];else if (typeof args[1] === 'string') type = args[1];else throw new Error('Invalid type or networkId, type must be string, networkId must be number');\n    }\n  }\n\n  if (type === undefined) type = randomAddressType();\n  if (netId === undefined) netId = 1029;\n  const hexAddress = stripHexPrefix(randomHexAddress(type));\n  return encode(Buffer.from(hexAddress, 'hex'), netId);\n};","map":{"version":3,"sources":["/Users/alice/Documents/rigel/node_modules/@cfxjs/base32-address/index.js"],"names":["encode","encodeBase32","decode","decodeBase32","toWords","fromWords","Buffer","randomHexAddress","randomAddressType","stripHexPrefix","VERSION_BYTE","NET_ID_LIMIT","encodeNetId","netId","Number","isInteger","Error","isValidNetId","test","decodeNetId","payload","prefix","slice","encodePayload","hexAddress","concat","from","decodePayload","getAddressType","length","x","verbose","addressType","encodedAddress","split","join","toUpperCase","address","lowered","toLowerCase","uppered","splits","shouldHaveType","reducedAddress","result","data","words","returnValue","type","validateBase32Address","args","decoded","valid","undefined","isSafeInteger","err","randomBase32Address"],"mappings":"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","sourcesContent":["import {\n  encode as encodeBase32,\n  decode as decodeBase32,\n  toWords,\n  fromWords,\n} from '@cfxjs/base32'\nimport {Buffer} from 'buffer'\nimport {randomHexAddress, randomAddressType} from '@cfxjs/account'\nimport {stripHexPrefix} from '@cfxjs/utils'\n\nconst VERSION_BYTE = 0\nconst NET_ID_LIMIT = 0xffffffff\n\nfunction encodeNetId(netId) {\n  if (!Number.isInteger(netId)) {\n    throw new Error('netId should be passed as an integer')\n  }\n  if (netId <= 0 || netId > NET_ID_LIMIT) {\n    throw new Error('netId should be passed as in range [1, 0xFFFFFFFF]')\n  }\n\n  switch (netId) {\n    case 1:\n      return 'cfxtest'\n    case 1029:\n      return 'cfx'\n    default:\n      return `net${netId}`\n  }\n}\n\nfunction isValidNetId(netId) {\n  return /^([1-9]\\d*)$/.test(netId) && Number(netId) <= NET_ID_LIMIT\n}\n\nfunction decodeNetId(payload) {\n  switch (payload) {\n    case 'cfxtest':\n      return 1\n    case 'cfx':\n      return 1029\n    default: {\n      const prefix = payload.slice(0, 3)\n      const netId = payload.slice(3)\n      if (prefix !== 'net' || !isValidNetId(netId)) {\n        throw new Error(\n          \"netId prefix should be passed by 'cfx', 'cfxtest' or 'net[n]' \",\n        )\n      }\n      if (Number(netId) === 1 || Number(netId) === 1029) {\n        throw new Error('net1 or net1029 are invalid')\n      }\n      return Number(netId)\n    }\n  }\n}\n\nfunction encodePayload(hexAddress) {\n  return Buffer.concat([Buffer.from([VERSION_BYTE]), hexAddress])\n}\n\nfunction decodePayload(payload) {\n  if (payload[0] !== VERSION_BYTE) {\n    throw new Error('Can not recognize version byte')\n  }\n  return Buffer.from(payload.slice(1))\n}\n\nfunction getAddressType(hexAddress) {\n  if (hexAddress.length < 1) {\n    throw new Error('Empty payload in address')\n  }\n  switch (hexAddress[0] & 0xf0) {\n    case 0x10:\n      return 'user'\n    case 0x80:\n      return 'contract'\n    case 0x00:\n      for (const x of hexAddress) {\n        if (x !== 0x00) {\n          return 'builtin'\n        }\n      }\n      return 'null'\n    default:\n      throw new Error('hexAddress should start with 0x0, 0x1 or 0x8')\n  }\n}\n\nexport function encode(hexAddress, netId, verbose = false) {\n  if (!(hexAddress instanceof Buffer)) {\n    throw new Error('hexAddress should be passed as a Buffer')\n  }\n\n  if (hexAddress.length < 20) {\n    throw new Error('hexAddress should be at least 20 bytes')\n  }\n\n  const addressType = getAddressType(hexAddress)\n\n  let encodedAddress = encodeBase32(\n    encodeNetId(netId),\n    toWords(encodePayload(hexAddress)),\n  )\n\n  if (verbose) {\n    const [prefix, payload] = encodedAddress.split(':')\n    encodedAddress = [prefix, `type.${addressType}`, payload]\n      .join(':')\n      .toUpperCase()\n  }\n  return encodedAddress\n}\n\nexport function decode(address) {\n  // don't allow mixed case\n  const lowered = address.toLowerCase()\n  const uppered = address.toUpperCase()\n  if (address !== lowered && address !== uppered) {\n    throw new Error('Mixed-case address ' + address)\n  }\n\n  const splits = address.split(':')\n  let shouldHaveType = ''\n\n  let reducedAddress = address\n  if (splits.length === 3) {\n    shouldHaveType = splits[1]\n    reducedAddress = [splits[0], splits[2]].join(':')\n  }\n\n  const result = decodeBase32(reducedAddress)\n  const data = fromWords(result.words)\n  if (data.length < 1) {\n    throw new Error('Empty payload in address')\n  }\n\n  const returnValue = {\n    hexAddress: decodePayload(data),\n    netId: decodeNetId(result.prefix),\n    type: getAddressType(decodePayload(data)),\n  }\n\n  if (\n    shouldHaveType !== '' &&\n    `type.${returnValue.type}` !== shouldHaveType.toLowerCase()\n  ) {\n    throw new Error(\"Type of address doesn't match\")\n  }\n\n  return returnValue\n}\n\nexport function validateBase32Address(address, ...args) {\n  let netId, type, decoded\n\n  let valid = false\n\n  if (args[0] !== undefined && args[0] !== null) {\n    if (Number.isSafeInteger(args[0])) netId = args[0]\n    else if (typeof args[0] === 'string') type = args[0]\n    else\n      throw new Error(\n        'Invalid type or networkId, type must be string, networkId must be number',\n      )\n\n    if (args[1] !== undefined && args[1] !== null) {\n      if (Number.isSafeInteger(args[1])) netId = args[1]\n      else if (typeof args[1] === 'string') type = args[1]\n      else\n        throw new Error(\n          'Invalid type or networkId, type must be string, networkId must be number',\n        )\n    }\n  }\n\n  try {\n    decoded = decode(address)\n    valid = true\n    if (netId !== undefined && netId !== decoded.netId) valid = false\n    if (type !== undefined && type !== decoded.type) valid = false\n  } catch (err) {\n    valid = false\n  }\n\n  return valid\n}\n\nexport const randomBase32Address = (...args) => {\n  let netId, type\n\n  if (args[0] !== undefined && args[0] !== null) {\n    if (Number.isSafeInteger(args[0])) netId = args[0]\n    else if (typeof args[0] === 'string') type = args[0]\n    else\n      throw new Error(\n        'Invalid type or networkId, type must be string, networkId must be number',\n      )\n    if (args[1] !== undefined && args[1] !== null) {\n      if (Number.isSafeInteger(args[1])) netId = args[1]\n      else if (typeof args[1] === 'string') type = args[1]\n      else\n        throw new Error(\n          'Invalid type or networkId, type must be string, networkId must be number',\n        )\n    }\n  }\n\n  if (type === undefined) type = randomAddressType()\n  if (netId === undefined) netId = 1029\n\n  const hexAddress = stripHexPrefix(randomHexAddress(type))\n\n  return encode(Buffer.from(hexAddress, 'hex'), netId)\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$(),\n    _s11 = $RefreshSig$();\n\n/* eslint-disable react-hooks/exhaustive-deps */\nimport { useMemo, useEffect } from 'react';\nimport useSWR from 'swr';\nimport { requestAllTokenList, requestToken } from '../utils/api';\nimport { ProxyUrlPrefix, IntervalTime } from '../constants';\nimport { ChainConfig } from '../constants/chainConfig';\nimport { useIsCfxChain } from '../hooks';\nimport { useShuttleState } from '../state';\n\nfunction mapToken(token, isCfxChain) {\n  if (!token) return {};\n  const {\n    ctoken,\n    symbol,\n    name,\n    reference,\n    reference_symbol,\n    reference_name,\n    ...others\n  } = token;\n  return { ...others,\n    //display_symbol, display_name, address is only for dispalying\n    // ctoken, symbol, name is conflux token info\n    // reference, reference_symbol, reference_name is other chain token info\n    display_symbol: isCfxChain ? symbol : reference_symbol,\n    display_name: isCfxChain ? name : reference_name,\n    address: isCfxChain ? ctoken : reference,\n    // address may be string, such as 'eth', 'cfx'\n    ctoken,\n    symbol,\n    name,\n    reference,\n    reference_symbol,\n    reference_name\n  };\n} // only use for display\n\n\nexport function useDisplayTokenList(fromChain, toChain) {\n  _s();\n\n  const tokenList = useMapTokenList(fromChain, toChain);\n  return useMemo(() => tokenList.filter(ChainConfig[fromChain].displayFilter), [fromChain, tokenList.toString()]);\n} // filter with fromChain and toChain, then map token\n\n_s(useDisplayTokenList, \"UJSK+1j/ti9dEMMJ7SFudLbppSY=\", false, function () {\n  return [useMapTokenList];\n});\n\nexport function useMapTokenList(fromChain, toChain) {\n  _s2();\n\n  const tokenList = useAllTokenList();\n  const isFromCfxChain = useIsCfxChain(fromChain);\n  return useMemo(() => tokenList.filter(token => (token === null || token === void 0 ? void 0 : token.origin) === fromChain || (token === null || token === void 0 ? void 0 : token.to_chain) === fromChain).filter(token => (token === null || token === void 0 ? void 0 : token.origin) === toChain || (token === null || token === void 0 ? void 0 : token.to_chain) === toChain).map(token => mapToken(token, isFromCfxChain)), [tokenList.toString(), isFromCfxChain, fromChain, toChain]);\n} // get all token list from backend\n\n_s2(useMapTokenList, \"QR9WSzQPSx+DGkOnHdInDRRRu9o=\", false, function () {\n  return [useAllTokenList, useIsCfxChain];\n});\n\nexport function useAllTokenList() {\n  _s3();\n\n  const {\n    data\n  } = useSWR(ProxyUrlPrefix.sponsor, requestAllTokenList, {\n    refreshInterval: IntervalTime.fetchTokenList,\n    suspense: true\n  });\n  return data ? data : [];\n} // search token address from backend\n\n_s3(useAllTokenList, \"0sj2yJGYzZcCGI13NamvRceNarI=\", false, function () {\n  return [useSWR];\n});\n\nfunction useSearchAddressFromBackend(fromChain, toChain, search) {\n  _s4();\n\n  var _searchTokensFromBack;\n\n  const isFromCfxChain = useIsCfxChain(fromChain);\n  const {\n    setTokenFromBackend\n  } = useShuttleState();\n  const searchTokens = useSearchAddressFromList(fromChain, toChain, search);\n  const {\n    data\n  } = useSWR(ChainConfig[fromChain].checkAddress(search) && searchTokens.length === 0 ? [ProxyUrlPrefix.sponsor, fromChain, toChain, search] : null, requestToken);\n  const searchTokensFromBackend = useMemo(() => data ? [data].map(token => mapToken(token, isFromCfxChain)) : [], [data === null || data === void 0 ? void 0 : data.reference, isFromCfxChain]);\n  useEffect(() => {\n    if (searchTokensFromBackend.length === 1) {\n      setTokenFromBackend(searchTokensFromBackend[0]);\n    }\n  }, [(_searchTokensFromBack = searchTokensFromBackend[0]) === null || _searchTokensFromBack === void 0 ? void 0 : _searchTokensFromBack.address]);\n  return searchTokensFromBackend;\n} // search token adddress from current list\n\n\n_s4(useSearchAddressFromBackend, \"VLrU1KtxkkC/NjGC+vqJF5elQNg=\", false, function () {\n  return [useIsCfxChain, useShuttleState, useSearchAddressFromList, useSWR];\n});\n\nfunction useSearchAddressFromList(fromChain, toChain, search) {\n  _s5();\n\n  const tokenList = useMapTokenList(fromChain, toChain);\n  const isValidAddress = ChainConfig[fromChain].checkAddress(search);\n  return useMemo(() => isValidAddress ? tokenList.filter(obj => {\n    return (obj === null || obj === void 0 ? void 0 : obj.address) === search;\n  }) : [], [isValidAddress, tokenList.toString(), search]);\n} // serach token name from current list\n\n\n_s5(useSearchAddressFromList, \"UJSK+1j/ti9dEMMJ7SFudLbppSY=\", false, function () {\n  return [useMapTokenList];\n});\n\nfunction useSearchNameFromList(fromChain, toChain, search) {\n  _s6();\n\n  const tokenList = useMapTokenList(fromChain, toChain);\n  return useMemo(() => tokenList.filter(obj => {\n    var _obj$display_symbol, _obj$display_name;\n\n    return (obj === null || obj === void 0 ? void 0 : (_obj$display_symbol = obj.display_symbol) === null || _obj$display_symbol === void 0 ? void 0 : _obj$display_symbol.toLowerCase().indexOf(search)) > -1 || (obj === null || obj === void 0 ? void 0 : (_obj$display_name = obj.display_name) === null || _obj$display_name === void 0 ? void 0 : _obj$display_name.toLowerCase().indexOf(search)) > -1;\n  }), [search, tokenList.toString()]);\n}\n\n_s6(useSearchNameFromList, \"UJSK+1j/ti9dEMMJ7SFudLbppSY=\", false, function () {\n  return [useMapTokenList];\n});\n\nexport function useTokenListBySearch(fromChain, toChain, search) {\n  _s7();\n\n  const lowerSearch = search === null || search === void 0 ? void 0 : search.toLowerCase();\n  const tokenList = useDisplayTokenList(fromChain, toChain);\n  const searchAddressFromList = useSearchAddressFromList(fromChain, toChain, lowerSearch);\n  const searchAddressFromBackend = useSearchAddressFromBackend(fromChain, toChain, lowerSearch);\n  const searchNameFromList = useSearchNameFromList(fromChain, toChain, lowerSearch);\n  if (!search) return tokenList;\n  if (searchAddressFromList.length === 1) return searchAddressFromList;\n  if (searchAddressFromBackend.length === 1) return searchAddressFromBackend;\n  if (searchNameFromList.length > 0) return searchNameFromList;\n  return [];\n}\n\n_s7(useTokenListBySearch, \"X1utM+X6bxOY114lxVfAR+pSBGc=\", false, function () {\n  return [useDisplayTokenList, useSearchAddressFromList, useSearchAddressFromBackend, useSearchNameFromList];\n});\n\nexport function useCommonTokens(fromChain, toChain) {\n  _s8();\n\n  const tokenList = useDisplayTokenList(fromChain, toChain);\n  const commonTokens = ChainConfig[fromChain].commonTokens;\n  return commonTokens.map(address => {\n    return tokenList.filter(obj => address === (obj === null || obj === void 0 ? void 0 : obj.address))[0];\n  });\n}\n\n_s8(useCommonTokens, \"gVZx9aGHYnMOJBLvmrerAiEBuC4=\", false, function () {\n  return [useDisplayTokenList];\n});\n\nexport function useFromToken(fromChain, toChain, fromTokenAddress) {\n  _s9();\n\n  const tokenList = useMapTokenList(fromChain, toChain);\n  const data = useMemo(() => tokenList.filter(token => token.address === fromTokenAddress), [tokenList.toString(), fromTokenAddress]);\n  return data && data[0] || {};\n}\n\n_s9(useFromToken, \"2o3E+BJns3egWpz7rXc7WCHgAvE=\", false, function () {\n  return [useMapTokenList];\n});\n\nexport function useToToken(fromChain, toChain, fromTokenAddress) {\n  _s10();\n\n  const tokenList = useMapTokenList(toChain, fromChain);\n  const data = useMemo(() => tokenList.filter(token => token.address === token.ctoken && token.reference === fromTokenAddress || token.address === token.reference && token.ctoken === fromTokenAddress), [tokenList.toString(), fromTokenAddress]);\n  return data && data[0] || {};\n}\n\n_s10(useToToken, \"2o3E+BJns3egWpz7rXc7WCHgAvE=\", false, function () {\n  return [useMapTokenList];\n});\n\nexport function useTokenAddress(token, isCfxChain) {\n  _s11();\n\n  const {\n    ctoken,\n    reference\n  } = token;\n  return useMemo(() => !token ? '' : isCfxChain ? ctoken : reference, [ctoken, reference, isCfxChain, Boolean(token)]); // address may be string, such as 'eth', 'cfx'\n}\n\n_s11(useTokenAddress, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");","map":{"version":3,"sources":["/Users/alice/Documents/rigel/src/hooks/useTokenList.js"],"names":["useMemo","useEffect","useSWR","requestAllTokenList","requestToken","ProxyUrlPrefix","IntervalTime","ChainConfig","useIsCfxChain","useShuttleState","mapToken","token","isCfxChain","ctoken","symbol","name","reference","reference_symbol","reference_name","others","display_symbol","display_name","address","useDisplayTokenList","fromChain","toChain","tokenList","useMapTokenList","filter","displayFilter","toString","useAllTokenList","isFromCfxChain","origin","to_chain","map","data","sponsor","refreshInterval","fetchTokenList","suspense","useSearchAddressFromBackend","search","setTokenFromBackend","searchTokens","useSearchAddressFromList","checkAddress","length","searchTokensFromBackend","isValidAddress","obj","useSearchNameFromList","toLowerCase","indexOf","useTokenListBySearch","lowerSearch","searchAddressFromList","searchAddressFromBackend","searchNameFromList","useCommonTokens","commonTokens","useFromToken","fromTokenAddress","useToToken","useTokenAddress","Boolean"],"mappings":"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","sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\nimport {useMemo, useEffect} from 'react'\nimport useSWR from 'swr'\nimport {requestAllTokenList, requestToken} from '../utils/api'\nimport {ProxyUrlPrefix, IntervalTime} from '../constants'\nimport {ChainConfig} from '../constants/chainConfig'\nimport {useIsCfxChain} from '../hooks'\nimport {useShuttleState} from '../state'\n\nfunction mapToken(token, isCfxChain) {\n  if (!token) return {}\n  const {\n    ctoken,\n    symbol,\n    name,\n    reference,\n    reference_symbol,\n    reference_name,\n    ...others\n  } = token\n  return {\n    ...others,\n    //display_symbol, display_name, address is only for dispalying\n    // ctoken, symbol, name is conflux token info\n    // reference, reference_symbol, reference_name is other chain token info\n    display_symbol: isCfxChain ? symbol : reference_symbol,\n    display_name: isCfxChain ? name : reference_name,\n    address: isCfxChain ? ctoken : reference, // address may be string, such as 'eth', 'cfx'\n    ctoken,\n    symbol,\n    name,\n    reference,\n    reference_symbol,\n    reference_name,\n  }\n}\n\n// only use for display\nexport function useDisplayTokenList(fromChain, toChain) {\n  const tokenList = useMapTokenList(fromChain, toChain)\n\n  return useMemo(\n    () => tokenList.filter(ChainConfig[fromChain].displayFilter),\n    [fromChain, tokenList.toString()],\n  )\n}\n\n// filter with fromChain and toChain, then map token\nexport function useMapTokenList(fromChain, toChain) {\n  const tokenList = useAllTokenList()\n  const isFromCfxChain = useIsCfxChain(fromChain)\n\n  return useMemo(\n    () =>\n      tokenList\n        .filter(\n          token => token?.origin === fromChain || token?.to_chain === fromChain,\n        )\n        .filter(\n          token => token?.origin === toChain || token?.to_chain === toChain,\n        )\n        .map(token => mapToken(token, isFromCfxChain)),\n    [tokenList.toString(), isFromCfxChain, fromChain, toChain],\n  )\n}\n\n// get all token list from backend\nexport function useAllTokenList() {\n  const {data} = useSWR(ProxyUrlPrefix.sponsor, requestAllTokenList, {\n    refreshInterval: IntervalTime.fetchTokenList,\n    suspense: true,\n  })\n  return data ? data : []\n}\n\n// search token address from backend\nfunction useSearchAddressFromBackend(fromChain, toChain, search) {\n  const isFromCfxChain = useIsCfxChain(fromChain)\n  const {setTokenFromBackend} = useShuttleState()\n  const searchTokens = useSearchAddressFromList(fromChain, toChain, search)\n  const {data} = useSWR(\n    ChainConfig[fromChain].checkAddress(search) && searchTokens.length === 0\n      ? [ProxyUrlPrefix.sponsor, fromChain, toChain, search]\n      : null,\n    requestToken,\n  )\n  const searchTokensFromBackend = useMemo(\n    () => (data ? [data].map(token => mapToken(token, isFromCfxChain)) : []),\n    [data?.reference, isFromCfxChain],\n  )\n  useEffect(() => {\n    if (searchTokensFromBackend.length === 1) {\n      setTokenFromBackend(searchTokensFromBackend[0])\n    }\n  }, [searchTokensFromBackend[0]?.address])\n  return searchTokensFromBackend\n}\n\n// search token adddress from current list\nfunction useSearchAddressFromList(fromChain, toChain, search) {\n  const tokenList = useMapTokenList(fromChain, toChain)\n  const isValidAddress = ChainConfig[fromChain].checkAddress(search)\n\n  return useMemo(\n    () =>\n      isValidAddress\n        ? tokenList.filter(obj => {\n            return obj?.address === search\n          })\n        : [],\n    [isValidAddress, tokenList.toString(), search],\n  )\n}\n\n// serach token name from current list\nfunction useSearchNameFromList(fromChain, toChain, search) {\n  const tokenList = useMapTokenList(fromChain, toChain)\n\n  return useMemo(\n    () =>\n      tokenList.filter(obj => {\n        return (\n          obj?.display_symbol?.toLowerCase().indexOf(search) > -1 ||\n          obj?.display_name?.toLowerCase().indexOf(search) > -1\n        )\n      }),\n    [search, tokenList.toString()],\n  )\n}\n\nexport function useTokenListBySearch(fromChain, toChain, search) {\n  const lowerSearch = search?.toLowerCase()\n  const tokenList = useDisplayTokenList(fromChain, toChain)\n  const searchAddressFromList = useSearchAddressFromList(\n    fromChain,\n    toChain,\n    lowerSearch,\n  )\n  const searchAddressFromBackend = useSearchAddressFromBackend(\n    fromChain,\n    toChain,\n    lowerSearch,\n  )\n  const searchNameFromList = useSearchNameFromList(\n    fromChain,\n    toChain,\n    lowerSearch,\n  )\n\n  if (!search) return tokenList\n  if (searchAddressFromList.length === 1) return searchAddressFromList\n  if (searchAddressFromBackend.length === 1) return searchAddressFromBackend\n  if (searchNameFromList.length > 0) return searchNameFromList\n  return []\n}\n\nexport function useCommonTokens(fromChain, toChain) {\n  const tokenList = useDisplayTokenList(fromChain, toChain)\n  const commonTokens = ChainConfig[fromChain].commonTokens\n  return commonTokens.map(address => {\n    return tokenList.filter(obj => address === obj?.address)[0]\n  })\n}\n\nexport function useFromToken(fromChain, toChain, fromTokenAddress) {\n  const tokenList = useMapTokenList(fromChain, toChain)\n\n  const data = useMemo(\n    () => tokenList.filter(token => token.address === fromTokenAddress),\n    [tokenList.toString(), fromTokenAddress],\n  )\n\n  return (data && data[0]) || {}\n}\n\nexport function useToToken(fromChain, toChain, fromTokenAddress) {\n  const tokenList = useMapTokenList(toChain, fromChain)\n\n  const data = useMemo(\n    () =>\n      tokenList.filter(\n        token =>\n          (token.address === token.ctoken &&\n            token.reference === fromTokenAddress) ||\n          (token.address === token.reference &&\n            token.ctoken === fromTokenAddress),\n      ),\n    [tokenList.toString(), fromTokenAddress],\n  )\n\n  return (data && data[0]) || {}\n}\n\nexport function useTokenAddress(token, isCfxChain) {\n  const {ctoken, reference} = token\n  return useMemo(\n    () => (!token ? '' : isCfxChain ? ctoken : reference),\n    [ctoken, reference, isCfxChain, Boolean(token)],\n  ) // address may be string, such as 'eth', 'cfx'\n}\n"]},"metadata":{},"sourceType":"module"}
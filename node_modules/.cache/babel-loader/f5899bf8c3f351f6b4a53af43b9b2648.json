{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\n/* eslint-disable react-hooks/exhaustive-deps */\n\n/**\n * data about shuttle, mainly various contract params\n */\nimport { useState, useEffect } from 'react';\nimport Big from 'big.js';\nimport { useShuttleContract } from './useShuttleContract';\nimport { ContractType } from '../constants/contractConfig';\nimport { KeyOfBtc, KeyOfCfx } from '../constants/chainConfig';\nimport { ZeroAddrHex } from '../constants';\nimport { useIsCfxChain } from '../hooks';\nimport { useTokenAddress } from '../hooks/useTokenList';\nimport { getExponent } from '../utils';\nexport function useShuttleData() {}\n/**\n *\n * @param {*} chainOfContract which chain this contract in\n * @param {*} token\n * @returns\n */\n\nexport function useCustodianData(chainOfContract, token) {\n  _s();\n\n  const {\n    origin,\n    decimals,\n    ctoken\n  } = token;\n  const isCfxChain = useIsCfxChain(origin);\n  let contractAddress = useTokenAddress(token, isCfxChain);\n\n  if (ctoken === KeyOfCfx) {\n    contractAddress = ZeroAddrHex;\n  }\n\n  const obverseContract = useShuttleContract(ContractType.custodianImpl, chainOfContract);\n  const reverseContract = useShuttleContract(ContractType.custodianImplReverse, chainOfContract);\n  const contract = isCfxChain ? reverseContract : obverseContract;\n  const dicimalsNum = getExponent(decimals);\n  const [contractData, setContractData] = useState({});\n  useEffect(() => {\n    if (!origin || !contract) {\n      setContractData({});\n      return;\n    }\n\n    Promise.all([contract['burn_fee'](contractAddress), contract['mint_fee'](contractAddress), contract['wallet_fee'](contractAddress), contractAddress === KeyOfBtc ? contract['btc_minimal_burn_value']() : contract['minimal_mint_value'](contractAddress), contractAddress === KeyOfBtc ? contract['btc_minimal_burn_value']() : contract['minimal_burn_value'](contractAddress), contract['minimal_sponsor_amount'](), contract['safe_sponsor_amount']()].map(fn => fn.call())).then(data => {\n      const [burn_fee, mint_fee, wallet_fee, minimal_mint_value, minimal_burn_value, minimal_sponsor_amount, safe_sponsor_amount] = data.map(x => Big(x));\n      setContractData({\n        //   in_fee: isCfxChain\n        //     ? burn_fee.div(`${dicimalsNum}`)\n        //     : mint_fee.div(`${dicimalsNum}`),\n        in_fee: Big(0),\n        //shuttle in fee has already benn zero in new version\n        out_fee: isCfxChain ? mint_fee.div(`${dicimalsNum}`) : burn_fee.div(`${dicimalsNum}`),\n        wallet_fee: wallet_fee.div(`${dicimalsNum}`),\n        //   minimal_in_value: isCfxChain\n        //     ? minimal_burn_value.div(`${dicimalsNum}`)\n        //     : minimal_mint_value.div(`${dicimalsNum}`),\n        minimal_in_value: Big(0),\n        // the minimal shuttle-in vlaue has already benn zero in new version\n        minimal_out_value: isCfxChain ? minimal_mint_value.div(`${dicimalsNum}`) : minimal_burn_value.div(`${dicimalsNum}`),\n        minimal_sponsor_amount: minimal_sponsor_amount.div(getExponent(18)),\n        safe_sponsor_amount: safe_sponsor_amount.div(getExponent(18))\n      });\n    }).catch(() => {\n      setContractData({});\n    });\n  }, [isCfxChain, chainOfContract, contractAddress, dicimalsNum, origin, Boolean(contract)]);\n  return contractData;\n}\n\n_s(useCustodianData, \"NknuDHL/QYGOcwPkhhb0xfxCMXo=\", false, function () {\n  return [useIsCfxChain, useTokenAddress, useShuttleContract, useShuttleContract];\n});\n\nexport function useSponsorData(chainOfContract, token) {\n  _s2();\n\n  const {\n    origin,\n    ctoken\n  } = token;\n  const isCfxChain = useIsCfxChain(origin);\n  let contractAddress = useTokenAddress(token, isCfxChain);\n\n  if (ctoken === KeyOfCfx) {\n    contractAddress = ZeroAddrHex;\n  }\n\n  const obverseData = useShuttleContract(ContractType.tokenSponsor, chainOfContract);\n  const reverseData = useShuttleContract(ContractType.tokenSponsorReverse, chainOfContract);\n  const contract = isCfxChain ? reverseData : obverseData;\n  const [contractData, setContractData] = useState({});\n  useEffect(() => {\n    if (!origin || !contract) {\n      setContractData({});\n      return;\n    }\n\n    Promise.all([contract['sponsorOf'](contractAddress), contract['sponsorValueOf'](contractAddress)].map(fn => fn.call())).then(data => {\n      var _Big;\n\n      setContractData({\n        sponsor: data[0],\n        sponsorValue: (_Big = Big(data[1])) === null || _Big === void 0 ? void 0 : _Big.div(getExponent(18))\n      });\n    }).catch(() => {\n      setContractData({});\n    });\n  }, [chainOfContract, isCfxChain, contractAddress, origin, Boolean(contract)]);\n  return contractData;\n}\n\n_s2(useSponsorData, \"FSQ99h/42PvGIrMs9wi5Hh63GFc=\", false, function () {\n  return [useIsCfxChain, useTokenAddress, useShuttleContract, useShuttleContract];\n});\n\nexport function useShuttleFee(chainOfContract, token, toChain) {\n  _s3();\n\n  const isToChainCfx = useIsCfxChain(toChain);\n  const {\n    in_fee,\n    out_fee\n  } = useCustodianData(chainOfContract, token);\n  return isToChainCfx ? in_fee ? in_fee.toString(10) : '0' : out_fee ? out_fee.toString(10) : '0';\n}\n\n_s3(useShuttleFee, \"FsJoxhslrB04FvEY1kfAAMxBdwE=\", false, function () {\n  return [useIsCfxChain, useCustodianData];\n});","map":{"version":3,"sources":["/Users/alice/Documents/rigel/src/hooks/useShuttleData.js"],"names":["useState","useEffect","Big","useShuttleContract","ContractType","KeyOfBtc","KeyOfCfx","ZeroAddrHex","useIsCfxChain","useTokenAddress","getExponent","useShuttleData","useCustodianData","chainOfContract","token","origin","decimals","ctoken","isCfxChain","contractAddress","obverseContract","custodianImpl","reverseContract","custodianImplReverse","contract","dicimalsNum","contractData","setContractData","Promise","all","map","fn","call","then","data","burn_fee","mint_fee","wallet_fee","minimal_mint_value","minimal_burn_value","minimal_sponsor_amount","safe_sponsor_amount","x","in_fee","out_fee","div","minimal_in_value","minimal_out_value","catch","Boolean","useSponsorData","obverseData","tokenSponsor","reverseData","tokenSponsorReverse","sponsor","sponsorValue","useShuttleFee","toChain","isToChainCfx","toString"],"mappings":";;;;AAAA;;AACA;AACA;AACA;AACA,SAAQA,QAAR,EAAkBC,SAAlB,QAAkC,OAAlC;AACA,OAAOC,GAAP,MAAgB,QAAhB;AACA,SAAQC,kBAAR,QAAiC,sBAAjC;AACA,SAAQC,YAAR,QAA2B,6BAA3B;AACA,SAAQC,QAAR,EAAkBC,QAAlB,QAAiC,0BAAjC;AACA,SAAQC,WAAR,QAA0B,cAA1B;AACA,SAAQC,aAAR,QAA4B,UAA5B;AACA,SAAQC,eAAR,QAA8B,uBAA9B;AACA,SAAQC,WAAR,QAA0B,UAA1B;AAEA,OAAO,SAASC,cAAT,GAA0B,CAAE;AAEnC;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,gBAAT,CAA0BC,eAA1B,EAA2CC,KAA3C,EAAkD;AAAA;;AACvD,QAAM;AAACC,IAAAA,MAAD;AAASC,IAAAA,QAAT;AAAmBC,IAAAA;AAAnB,MAA6BH,KAAnC;AACA,QAAMI,UAAU,GAAGV,aAAa,CAACO,MAAD,CAAhC;AACA,MAAII,eAAe,GAAGV,eAAe,CAACK,KAAD,EAAQI,UAAR,CAArC;;AACA,MAAID,MAAM,KAAKX,QAAf,EAAyB;AACvBa,IAAAA,eAAe,GAAGZ,WAAlB;AACD;;AAED,QAAMa,eAAe,GAAGjB,kBAAkB,CACxCC,YAAY,CAACiB,aAD2B,EAExCR,eAFwC,CAA1C;AAIA,QAAMS,eAAe,GAAGnB,kBAAkB,CACxCC,YAAY,CAACmB,oBAD2B,EAExCV,eAFwC,CAA1C;AAIA,QAAMW,QAAQ,GAAGN,UAAU,GAAGI,eAAH,GAAqBF,eAAhD;AACA,QAAMK,WAAW,GAAGf,WAAW,CAACM,QAAD,CAA/B;AACA,QAAM,CAACU,YAAD,EAAeC,eAAf,IAAkC3B,QAAQ,CAAC,EAAD,CAAhD;AACAC,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAACc,MAAD,IAAW,CAACS,QAAhB,EAA0B;AACxBG,MAAAA,eAAe,CAAC,EAAD,CAAf;AACA;AACD;;AACDC,IAAAA,OAAO,CAACC,GAAR,CACE,CACEL,QAAQ,CAAC,UAAD,CAAR,CAAqBL,eAArB,CADF,EAEEK,QAAQ,CAAC,UAAD,CAAR,CAAqBL,eAArB,CAFF,EAGEK,QAAQ,CAAC,YAAD,CAAR,CAAuBL,eAAvB,CAHF,EAIEA,eAAe,KAAKd,QAApB,GACImB,QAAQ,CAAC,wBAAD,CAAR,EADJ,GAEIA,QAAQ,CAAC,oBAAD,CAAR,CAA+BL,eAA/B,CANN,EAOEA,eAAe,KAAKd,QAApB,GACImB,QAAQ,CAAC,wBAAD,CAAR,EADJ,GAEIA,QAAQ,CAAC,oBAAD,CAAR,CAA+BL,eAA/B,CATN,EAUEK,QAAQ,CAAC,wBAAD,CAAR,EAVF,EAWEA,QAAQ,CAAC,qBAAD,CAAR,EAXF,EAYEM,GAZF,CAYMC,EAAE,IAAIA,EAAE,CAACC,IAAH,EAZZ,CADF,EAeGC,IAfH,CAeQC,IAAI,IAAI;AACZ,YAAM,CACJC,QADI,EAEJC,QAFI,EAGJC,UAHI,EAIJC,kBAJI,EAKJC,kBALI,EAMJC,sBANI,EAOJC,mBAPI,IAQFP,IAAI,CAACJ,GAAL,CAASY,CAAC,IAAIxC,GAAG,CAACwC,CAAD,CAAjB,CARJ;AAUAf,MAAAA,eAAe,CAAC;AACd;AACA;AACA;AACAgB,QAAAA,MAAM,EAAEzC,GAAG,CAAC,CAAD,CAJG;AAIE;AAChB0C,QAAAA,OAAO,EAAE1B,UAAU,GACfkB,QAAQ,CAACS,GAAT,CAAc,GAAEpB,WAAY,EAA5B,CADe,GAEfU,QAAQ,CAACU,GAAT,CAAc,GAAEpB,WAAY,EAA5B,CAPU;AAQdY,QAAAA,UAAU,EAAEA,UAAU,CAACQ,GAAX,CAAgB,GAAEpB,WAAY,EAA9B,CARE;AASd;AACA;AACA;AACAqB,QAAAA,gBAAgB,EAAE5C,GAAG,CAAC,CAAD,CAZP;AAYY;AAC1B6C,QAAAA,iBAAiB,EAAE7B,UAAU,GACzBoB,kBAAkB,CAACO,GAAnB,CAAwB,GAAEpB,WAAY,EAAtC,CADyB,GAEzBc,kBAAkB,CAACM,GAAnB,CAAwB,GAAEpB,WAAY,EAAtC,CAfU;AAgBde,QAAAA,sBAAsB,EAAEA,sBAAsB,CAACK,GAAvB,CAA2BnC,WAAW,CAAC,EAAD,CAAtC,CAhBV;AAiBd+B,QAAAA,mBAAmB,EAAEA,mBAAmB,CAACI,GAApB,CAAwBnC,WAAW,CAAC,EAAD,CAAnC;AAjBP,OAAD,CAAf;AAmBD,KA7CH,EA8CGsC,KA9CH,CA8CS,MAAM;AACXrB,MAAAA,eAAe,CAAC,EAAD,CAAf;AACD,KAhDH;AAiDD,GAtDQ,EAsDN,CACDT,UADC,EAEDL,eAFC,EAGDM,eAHC,EAIDM,WAJC,EAKDV,MALC,EAMDkC,OAAO,CAACzB,QAAD,CANN,CAtDM,CAAT;AA8DA,SAAOE,YAAP;AACD;;GAlFed,gB;UAEKJ,a,EACGC,e,EAKEN,kB,EAIAA,kB;;;AAwE1B,OAAO,SAAS+C,cAAT,CAAwBrC,eAAxB,EAAyCC,KAAzC,EAAgD;AAAA;;AACrD,QAAM;AAACC,IAAAA,MAAD;AAASE,IAAAA;AAAT,MAAmBH,KAAzB;AACA,QAAMI,UAAU,GAAGV,aAAa,CAACO,MAAD,CAAhC;AACA,MAAII,eAAe,GAAGV,eAAe,CAACK,KAAD,EAAQI,UAAR,CAArC;;AACA,MAAID,MAAM,KAAKX,QAAf,EAAyB;AACvBa,IAAAA,eAAe,GAAGZ,WAAlB;AACD;;AACD,QAAM4C,WAAW,GAAGhD,kBAAkB,CACpCC,YAAY,CAACgD,YADuB,EAEpCvC,eAFoC,CAAtC;AAIA,QAAMwC,WAAW,GAAGlD,kBAAkB,CACpCC,YAAY,CAACkD,mBADuB,EAEpCzC,eAFoC,CAAtC;AAIA,QAAMW,QAAQ,GAAGN,UAAU,GAAGmC,WAAH,GAAiBF,WAA5C;AACA,QAAM,CAACzB,YAAD,EAAeC,eAAf,IAAkC3B,QAAQ,CAAC,EAAD,CAAhD;AACAC,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAACc,MAAD,IAAW,CAACS,QAAhB,EAA0B;AACxBG,MAAAA,eAAe,CAAC,EAAD,CAAf;AACA;AACD;;AACDC,IAAAA,OAAO,CAACC,GAAR,CACE,CACEL,QAAQ,CAAC,WAAD,CAAR,CAAsBL,eAAtB,CADF,EAEEK,QAAQ,CAAC,gBAAD,CAAR,CAA2BL,eAA3B,CAFF,EAGEW,GAHF,CAGMC,EAAE,IAAIA,EAAE,CAACC,IAAH,EAHZ,CADF,EAMGC,IANH,CAMQC,IAAI,IAAI;AAAA;;AACZP,MAAAA,eAAe,CAAC;AACd4B,QAAAA,OAAO,EAAErB,IAAI,CAAC,CAAD,CADC;AAEdsB,QAAAA,YAAY,UAAEtD,GAAG,CAACgC,IAAI,CAAC,CAAD,CAAL,CAAL,yCAAE,KAAcW,GAAd,CAAkBnC,WAAW,CAAC,EAAD,CAA7B;AAFA,OAAD,CAAf;AAID,KAXH,EAYGsC,KAZH,CAYS,MAAM;AACXrB,MAAAA,eAAe,CAAC,EAAD,CAAf;AACD,KAdH;AAeD,GApBQ,EAoBN,CAACd,eAAD,EAAkBK,UAAlB,EAA8BC,eAA9B,EAA+CJ,MAA/C,EAAuDkC,OAAO,CAACzB,QAAD,CAA9D,CApBM,CAAT;AAqBA,SAAOE,YAAP;AACD;;IAvCewB,c;UAEK1C,a,EACGC,e,EAIFN,kB,EAIAA,kB;;;AA8BtB,OAAO,SAASsD,aAAT,CAAuB5C,eAAvB,EAAwCC,KAAxC,EAA+C4C,OAA/C,EAAwD;AAAA;;AAC7D,QAAMC,YAAY,GAAGnD,aAAa,CAACkD,OAAD,CAAlC;AACA,QAAM;AAACf,IAAAA,MAAD;AAASC,IAAAA;AAAT,MAAoBhC,gBAAgB,CAACC,eAAD,EAAkBC,KAAlB,CAA1C;AACA,SAAO6C,YAAY,GACfhB,MAAM,GACJA,MAAM,CAACiB,QAAP,CAAgB,EAAhB,CADI,GAEJ,GAHa,GAIfhB,OAAO,GACPA,OAAO,CAACgB,QAAR,CAAiB,EAAjB,CADO,GAEP,GANJ;AAOD;;IAVeH,a;UACOjD,a,EACKI,gB","sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\n/**\n * data about shuttle, mainly various contract params\n */\nimport {useState, useEffect} from 'react'\nimport Big from 'big.js'\nimport {useShuttleContract} from './useShuttleContract'\nimport {ContractType} from '../constants/contractConfig'\nimport {KeyOfBtc, KeyOfCfx} from '../constants/chainConfig'\nimport {ZeroAddrHex} from '../constants'\nimport {useIsCfxChain} from '../hooks'\nimport {useTokenAddress} from '../hooks/useTokenList'\nimport {getExponent} from '../utils'\n\nexport function useShuttleData() {}\n\n/**\n *\n * @param {*} chainOfContract which chain this contract in\n * @param {*} token\n * @returns\n */\nexport function useCustodianData(chainOfContract, token) {\n  const {origin, decimals, ctoken} = token\n  const isCfxChain = useIsCfxChain(origin)\n  let contractAddress = useTokenAddress(token, isCfxChain)\n  if (ctoken === KeyOfCfx) {\n    contractAddress = ZeroAddrHex\n  }\n\n  const obverseContract = useShuttleContract(\n    ContractType.custodianImpl,\n    chainOfContract,\n  )\n  const reverseContract = useShuttleContract(\n    ContractType.custodianImplReverse,\n    chainOfContract,\n  )\n  const contract = isCfxChain ? reverseContract : obverseContract\n  const dicimalsNum = getExponent(decimals)\n  const [contractData, setContractData] = useState({})\n  useEffect(() => {\n    if (!origin || !contract) {\n      setContractData({})\n      return\n    }\n    Promise.all(\n      [\n        contract['burn_fee'](contractAddress),\n        contract['mint_fee'](contractAddress),\n        contract['wallet_fee'](contractAddress),\n        contractAddress === KeyOfBtc\n          ? contract['btc_minimal_burn_value']()\n          : contract['minimal_mint_value'](contractAddress),\n        contractAddress === KeyOfBtc\n          ? contract['btc_minimal_burn_value']()\n          : contract['minimal_burn_value'](contractAddress),\n        contract['minimal_sponsor_amount'](),\n        contract['safe_sponsor_amount'](),\n      ].map(fn => fn.call()),\n    )\n      .then(data => {\n        const [\n          burn_fee,\n          mint_fee,\n          wallet_fee,\n          minimal_mint_value,\n          minimal_burn_value,\n          minimal_sponsor_amount,\n          safe_sponsor_amount,\n        ] = data.map(x => Big(x))\n\n        setContractData({\n          //   in_fee: isCfxChain\n          //     ? burn_fee.div(`${dicimalsNum}`)\n          //     : mint_fee.div(`${dicimalsNum}`),\n          in_fee: Big(0), //shuttle in fee has already benn zero in new version\n          out_fee: isCfxChain\n            ? mint_fee.div(`${dicimalsNum}`)\n            : burn_fee.div(`${dicimalsNum}`),\n          wallet_fee: wallet_fee.div(`${dicimalsNum}`),\n          //   minimal_in_value: isCfxChain\n          //     ? minimal_burn_value.div(`${dicimalsNum}`)\n          //     : minimal_mint_value.div(`${dicimalsNum}`),\n          minimal_in_value: Big(0), // the minimal shuttle-in vlaue has already benn zero in new version\n          minimal_out_value: isCfxChain\n            ? minimal_mint_value.div(`${dicimalsNum}`)\n            : minimal_burn_value.div(`${dicimalsNum}`),\n          minimal_sponsor_amount: minimal_sponsor_amount.div(getExponent(18)),\n          safe_sponsor_amount: safe_sponsor_amount.div(getExponent(18)),\n        })\n      })\n      .catch(() => {\n        setContractData({})\n      })\n  }, [\n    isCfxChain,\n    chainOfContract,\n    contractAddress,\n    dicimalsNum,\n    origin,\n    Boolean(contract),\n  ])\n  return contractData\n}\n\nexport function useSponsorData(chainOfContract, token) {\n  const {origin, ctoken} = token\n  const isCfxChain = useIsCfxChain(origin)\n  let contractAddress = useTokenAddress(token, isCfxChain)\n  if (ctoken === KeyOfCfx) {\n    contractAddress = ZeroAddrHex\n  }\n  const obverseData = useShuttleContract(\n    ContractType.tokenSponsor,\n    chainOfContract,\n  )\n  const reverseData = useShuttleContract(\n    ContractType.tokenSponsorReverse,\n    chainOfContract,\n  )\n  const contract = isCfxChain ? reverseData : obverseData\n  const [contractData, setContractData] = useState({})\n  useEffect(() => {\n    if (!origin || !contract) {\n      setContractData({})\n      return\n    }\n    Promise.all(\n      [\n        contract['sponsorOf'](contractAddress),\n        contract['sponsorValueOf'](contractAddress),\n      ].map(fn => fn.call()),\n    )\n      .then(data => {\n        setContractData({\n          sponsor: data[0],\n          sponsorValue: Big(data[1])?.div(getExponent(18)),\n        })\n      })\n      .catch(() => {\n        setContractData({})\n      })\n  }, [chainOfContract, isCfxChain, contractAddress, origin, Boolean(contract)])\n  return contractData\n}\n\nexport function useShuttleFee(chainOfContract, token, toChain) {\n  const isToChainCfx = useIsCfxChain(toChain)\n  const {in_fee, out_fee} = useCustodianData(chainOfContract, token)\n  return isToChainCfx\n    ? in_fee\n      ? in_fee.toString(10)\n      : '0'\n    : out_fee\n    ? out_fee.toString(10)\n    : '0'\n}\n"]},"metadata":{},"sourceType":"module"}
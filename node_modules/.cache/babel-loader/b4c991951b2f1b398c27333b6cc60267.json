{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$(),\n    _s11 = $RefreshSig$(),\n    _s12 = $RefreshSig$();\n\n/* eslint-disable react-hooks/exhaustive-deps */\n\n/**\n * For the chain based on Ethereum: multiple connectors\n * But only support MetaMask now\n */\nimport { useEffect, useState, useMemo } from 'react';\nimport { useWeb3React, UnsupportedChainIdError } from '@web3-react/core';\nimport { isMobile } from 'react-device-detect';\nimport { useInterval } from 'react-use';\nimport Big from 'big.js';\nimport { NetworkContextName, IntervalTime, BigNumZero, TypeConnectWallet } from '../constants';\nimport { injected, getContract } from '../utils/web3';\nimport { checkHexAddress } from '../utils/address';\nimport { ERC20_ABI } from '../abi';\n/**\n * doc: https://github.com/NoahZinsmeister/web3-react/tree/v6/docs#useweb3react\n * @returns context object\n * object details:\n  activate: (\n    connector: AbstractConnectorInterface,\n    onError?: (error: Error) => void,\n    throwErrors?: boolean\n  ) => Promise<void>\n  setError: (error: Error) => void\n  deactivate: () => void\n\n  connector?: AbstractConnectorInterface\n  library?: T\n  chainId?: number\n  account?: null | string\n\n  active: boolean\n  error?: Error\n */\n\nexport function useActiveWeb3React() {\n  _s();\n\n  const context = useWeb3React();\n  const contextNetwork = useWeb3React(NetworkContextName);\n  return context.active ? context : contextNetwork;\n}\n/**\n * Use for network and injected - logs user in\n * and out after checking what network theyre on\n */\n\n_s(useActiveWeb3React, \"tXu+0ZvK8Ypx1BiJyWHm2i1O0yA=\", false, function () {\n  return [useWeb3React, useWeb3React];\n});\n\nexport function useInactiveListener(suppress = false) {\n  _s2();\n\n  const {\n    active,\n    error,\n    activate\n  } = useWeb3React(); // specifically using useWeb3React because of what this hook does\n\n  useEffect(() => {\n    const {\n      ethereum\n    } = window;\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleChainChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch(error => {\n          console.error('Failed to activate after chain changed', error);\n        });\n      };\n\n      const handleAccountsChanged = accounts => {\n        if (accounts.length > 0) {\n          // eat errors\n          activate(injected, undefined, true).catch(error => {\n            console.error('Failed to activate after accounts changed', error);\n          });\n        }\n      };\n\n      ethereum.on('chainChanged', handleChainChanged);\n      ethereum.on('accountsChanged', handleAccountsChanged);\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('chainChanged', handleChainChanged);\n          ethereum.removeListener('accountsChanged', handleAccountsChanged);\n        }\n      };\n    }\n\n    return undefined;\n  }, [active, Boolean(error), suppress, activate]);\n}\n\n_s2(useInactiveListener, \"C69EQHl6GEeID8bMvdCGfuvLHLM=\", false, function () {\n  return [useWeb3React];\n});\n\nexport function useEagerConnect() {\n  _s3();\n\n  const {\n    activate,\n    active\n  } = useWeb3React(); // specifically using useWeb3React because of what this hook does\n\n  const [tried, setTried] = useState(false);\n  useEffect(() => {\n    injected.isAuthorized().then(isAuthorized => {\n      if (isAuthorized) {\n        activate(injected, undefined, true).catch(() => {\n          setTried(true);\n        });\n      } else {\n        if (window.ethereum && isMobile) {\n          activate(injected, undefined, true).catch(() => {\n            setTried(true);\n          });\n        } else {\n          setTried(true);\n        }\n      }\n    });\n  }, [activate]); // intentionally only running on mount (make sure it's only mounted once :))\n  // if the connection worked, wait until we get confirmation of that to flip the flag\n\n  useEffect(() => {\n    if (active) {\n      setTried(true);\n    }\n  }, [active]);\n  return tried;\n}\n\n_s3(useEagerConnect, \"kis58PF6v2HZqrSYQVFelIlZ8vc=\", false, function () {\n  return [useWeb3React];\n});\n\nexport function useInstalled() {\n  var _window;\n\n  const isInstalled = (_window = window) === null || _window === void 0 ? void 0 : _window.ethereum;\n  return isInstalled;\n}\nexport function useAddress() {\n  _s4();\n\n  const {\n    account\n  } = useWeb3React();\n  return account;\n}\n\n_s4(useAddress, \"h6/cZxpS6iqAcrsYY6AfDt6uP70=\", false, function () {\n  return [useWeb3React];\n});\n\nexport function useConnect() {\n  _s5();\n\n  const {\n    error,\n    account,\n    activate,\n    chainId\n  } = useWeb3React();\n  const isInstalled = useInstalled();\n  const [type, setType] = useState(isInstalled ? TypeConnectWallet.success : TypeConnectWallet.uninstalled);\n\n  const tryActivate = () => {\n    setType(TypeConnectWallet.loading);\n\n    if (isInstalled && !account) {\n      activate(injected, undefined, true).catch(error => {\n        if (error instanceof UnsupportedChainIdError) {\n          activate(injected);\n        } else {\n          setType(TypeConnectWallet.error);\n        }\n      });\n    }\n  };\n\n  return {\n    type,\n    setType,\n    tryActivate,\n    error,\n    address: account,\n    chainId\n  };\n}\n/**\n * Get the balance of Native Token, etc: the ETH token on the Ethereum chain\n * doc: https://github.com/streamich/react-use/blob/master/docs/useInterval.md\n * @param {*} address token address\n * @param {*} delay interval delay milliseconds\n * @returns the balance\n */\n\n_s5(useConnect, \"VSwmpo4gHxvfn9N60EjJRr5UuKg=\", false, function () {\n  return [useWeb3React, useInstalled];\n});\n\nexport function useNativeTokenBalance(address, delay = IntervalTime.fetchBalance) {\n  _s6();\n\n  const [balance, setBalance] = useState(BigNumZero);\n  const {\n    account,\n    library\n  } = useWeb3React();\n  useInterval(() => {\n    library && library.getBalance(address).then(newBalance => {\n      if (!balance.eq(newBalance)) {\n        setBalance(new Big(newBalance.toString(10)));\n      }\n    }).catch(() => {\n      setBalance(BigNumZero);\n    });\n  }, account ? delay : null);\n  return balance;\n} // returns null when has error\n\n_s6(useNativeTokenBalance, \"Guduc4hoWpN1fF7j29Lfu1PdlPs=\", false, function () {\n  return [useWeb3React, useInterval];\n});\n\nexport function useContract(address, ABI, withSignerIfPossible = true) {\n  _s7();\n\n  const {\n    library,\n    account\n  } = useActiveWeb3React();\n  return useMemo(() => {\n    if (!address || !ABI || !library || !checkHexAddress(address)) return null;\n\n    try {\n      return getContract(address, ABI, library, withSignerIfPossible && account ? account : undefined);\n    } catch (error) {\n      return null;\n    }\n  }, [address, Boolean(library), withSignerIfPossible, account]);\n}\n\n_s7(useContract, \"lJ4cGE4j3P6eRbQp05H9PxxXTF4=\", false, function () {\n  return [useActiveWeb3React];\n});\n\nexport function useTokenContract(tokenAddress, withSignerIfPossible = true) {\n  _s8();\n\n  return useContract(tokenAddress, ERC20_ABI, withSignerIfPossible);\n}\n\n_s8(useTokenContract, \"OieRxpBRupXKKSB/Daj7yBGbdgo=\", false, function () {\n  return [useContract];\n});\n\nexport function useTokenAllowance(tokenAddress, params) {\n  _s9();\n\n  const allowance = useContractState(tokenAddress, 'allowance', params);\n  return allowance || BigNumZero;\n}\n/**\n * call some method from contract and get the value\n * @param {*} contract\n * @param {*} method\n * @param {*} params\n * @returns\n */\n\n_s9(useTokenAllowance, \"WpwHO+PvngoOKGKaJt6F42J0Hmg=\", false, function () {\n  return [useContractState];\n});\n\nexport function useContractState(tokenAddress, method, params, interval) {\n  _s10();\n\n  const contract = useTokenContract(tokenAddress);\n  const [data, setData] = useState(null);\n  useEffect(() => {\n    const getContractData = params => {\n      contract === null || contract === void 0 ? void 0 : contract[method](...params).then(res => {\n        setData(res);\n      }).catch(() => {\n        setData(null);\n      });\n    };\n\n    if (interval) {\n      getContractData(params);\n      const timeInterval = setInterval(() => getContractData(params), interval);\n      return () => clearInterval(timeInterval);\n    } else {\n      getContractData(params);\n    }\n  }, [...params, interval, Boolean(contract)]);\n  return data;\n}\n\n_s10(useContractState, \"deBTBeY4A+/CVN+EGyJeGkHgqnE=\", false, function () {\n  return [useTokenContract];\n});\n\nexport function useTokenBalance(tokenAddress, params) {\n  _s11();\n\n  const balance = useContractState(tokenAddress, 'balanceOf', params, IntervalTime.fetchBalance);\n  return balance ? new Big(balance) : BigNumZero;\n}\n\n_s11(useTokenBalance, \"lbJAinXuh2SKFe8DzvttRkaHo64=\", false, function () {\n  return [useContractState];\n});\n\nexport function useBalance(address, tokenAddress) {\n  _s12();\n\n  const tokenBalance = useTokenBalance(tokenAddress, [address]) || BigNumZero;\n  const nativeTokenBalance = useNativeTokenBalance(address) || BigNumZero;\n  const isNativeToken = !checkHexAddress(tokenAddress);\n  return isNativeToken ? nativeTokenBalance : tokenBalance;\n}\n\n_s12(useBalance, \"3jg+U9xrTVLX1CSYByhrcSMQDtc=\", false, function () {\n  return [useTokenBalance, useNativeTokenBalance];\n});","map":{"version":3,"sources":["/Users/alice/Documents/rigel/src/hooks/useWeb3Network.js"],"names":["useEffect","useState","useMemo","useWeb3React","UnsupportedChainIdError","isMobile","useInterval","Big","NetworkContextName","IntervalTime","BigNumZero","TypeConnectWallet","injected","getContract","checkHexAddress","ERC20_ABI","useActiveWeb3React","context","contextNetwork","active","useInactiveListener","suppress","error","activate","ethereum","window","on","handleChainChanged","undefined","catch","console","handleAccountsChanged","accounts","length","removeListener","Boolean","useEagerConnect","tried","setTried","isAuthorized","then","useInstalled","isInstalled","useAddress","account","useConnect","chainId","type","setType","success","uninstalled","tryActivate","loading","address","useNativeTokenBalance","delay","fetchBalance","balance","setBalance","library","getBalance","newBalance","eq","toString","useContract","ABI","withSignerIfPossible","useTokenContract","tokenAddress","useTokenAllowance","params","allowance","useContractState","method","interval","contract","data","setData","getContractData","res","timeInterval","setInterval","clearInterval","useTokenBalance","useBalance","tokenBalance","nativeTokenBalance","isNativeToken"],"mappings":"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","sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\n/**\n * For the chain based on Ethereum: multiple connectors\n * But only support MetaMask now\n */\nimport {useEffect, useState, useMemo} from 'react'\nimport {useWeb3React, UnsupportedChainIdError} from '@web3-react/core'\nimport {isMobile} from 'react-device-detect'\nimport {useInterval} from 'react-use'\nimport Big from 'big.js'\nimport {\n  NetworkContextName,\n  IntervalTime,\n  BigNumZero,\n  TypeConnectWallet,\n} from '../constants'\nimport {injected, getContract} from '../utils/web3'\nimport {checkHexAddress} from '../utils/address'\nimport {ERC20_ABI} from '../abi'\n\n/**\n * doc: https://github.com/NoahZinsmeister/web3-react/tree/v6/docs#useweb3react\n * @returns context object\n * object details:\n  activate: (\n    connector: AbstractConnectorInterface,\n    onError?: (error: Error) => void,\n    throwErrors?: boolean\n  ) => Promise<void>\n  setError: (error: Error) => void\n  deactivate: () => void\n\n  connector?: AbstractConnectorInterface\n  library?: T\n  chainId?: number\n  account?: null | string\n\n  active: boolean\n  error?: Error\n */\nexport function useActiveWeb3React() {\n  const context = useWeb3React()\n  const contextNetwork = useWeb3React(NetworkContextName)\n  return context.active ? context : contextNetwork\n}\n\n/**\n * Use for network and injected - logs user in\n * and out after checking what network theyre on\n */\nexport function useInactiveListener(suppress = false) {\n  const {active, error, activate} = useWeb3React() // specifically using useWeb3React because of what this hook does\n\n  useEffect(() => {\n    const {ethereum} = window\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleChainChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch(error => {\n          console.error('Failed to activate after chain changed', error)\n        })\n      }\n\n      const handleAccountsChanged = accounts => {\n        if (accounts.length > 0) {\n          // eat errors\n          activate(injected, undefined, true).catch(error => {\n            console.error('Failed to activate after accounts changed', error)\n          })\n        }\n      }\n\n      ethereum.on('chainChanged', handleChainChanged)\n      ethereum.on('accountsChanged', handleAccountsChanged)\n\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('chainChanged', handleChainChanged)\n          ethereum.removeListener('accountsChanged', handleAccountsChanged)\n        }\n      }\n    }\n    return undefined\n  }, [active, Boolean(error), suppress, activate])\n}\n\nexport function useEagerConnect() {\n  const {activate, active} = useWeb3React() // specifically using useWeb3React because of what this hook does\n  const [tried, setTried] = useState(false)\n\n  useEffect(() => {\n    injected.isAuthorized().then(isAuthorized => {\n      if (isAuthorized) {\n        activate(injected, undefined, true).catch(() => {\n          setTried(true)\n        })\n      } else {\n        if (window.ethereum && isMobile) {\n          activate(injected, undefined, true).catch(() => {\n            setTried(true)\n          })\n        } else {\n          setTried(true)\n        }\n      }\n    })\n  }, [activate]) // intentionally only running on mount (make sure it's only mounted once :))\n\n  // if the connection worked, wait until we get confirmation of that to flip the flag\n  useEffect(() => {\n    if (active) {\n      setTried(true)\n    }\n  }, [active])\n\n  return tried\n}\n\nexport function useInstalled() {\n  const isInstalled = window?.ethereum\n  return isInstalled\n}\n\nexport function useAddress() {\n  const {account} = useWeb3React()\n  return account\n}\n\nexport function useConnect() {\n  const {error, account, activate, chainId} = useWeb3React()\n  const isInstalled = useInstalled()\n  const [type, setType] = useState(\n    isInstalled ? TypeConnectWallet.success : TypeConnectWallet.uninstalled,\n  )\n\n  const tryActivate = () => {\n    setType(TypeConnectWallet.loading)\n    if (isInstalled && !account) {\n      activate(injected, undefined, true).catch(error => {\n        if (error instanceof UnsupportedChainIdError) {\n          activate(injected)\n        } else {\n          setType(TypeConnectWallet.error)\n        }\n      })\n    }\n  }\n  return {type, setType, tryActivate, error, address: account, chainId}\n}\n\n/**\n * Get the balance of Native Token, etc: the ETH token on the Ethereum chain\n * doc: https://github.com/streamich/react-use/blob/master/docs/useInterval.md\n * @param {*} address token address\n * @param {*} delay interval delay milliseconds\n * @returns the balance\n */\nexport function useNativeTokenBalance(\n  address,\n  delay = IntervalTime.fetchBalance,\n) {\n  const [balance, setBalance] = useState(BigNumZero)\n  const {account, library} = useWeb3React()\n  useInterval(\n    () => {\n      library &&\n        library\n          .getBalance(address)\n          .then(newBalance => {\n            if (!balance.eq(newBalance)) {\n              setBalance(new Big(newBalance.toString(10)))\n            }\n          })\n          .catch(() => {\n            setBalance(BigNumZero)\n          })\n    },\n    account ? delay : null,\n  )\n  return balance\n}\n\n// returns null when has error\nexport function useContract(address, ABI, withSignerIfPossible = true) {\n  const {library, account} = useActiveWeb3React()\n  return useMemo(() => {\n    if (!address || !ABI || !library || !checkHexAddress(address)) return null\n    try {\n      return getContract(\n        address,\n        ABI,\n        library,\n        withSignerIfPossible && account ? account : undefined,\n      )\n    } catch (error) {\n      return null\n    }\n  }, [address, Boolean(library), withSignerIfPossible, account])\n}\n\nexport function useTokenContract(tokenAddress, withSignerIfPossible = true) {\n  return useContract(tokenAddress, ERC20_ABI, withSignerIfPossible)\n}\n\nexport function useTokenAllowance(tokenAddress, params) {\n  const allowance = useContractState(tokenAddress, 'allowance', params)\n  return allowance || BigNumZero\n}\n\n/**\n * call some method from contract and get the value\n * @param {*} contract\n * @param {*} method\n * @param {*} params\n * @returns\n */\nexport function useContractState(tokenAddress, method, params, interval) {\n  const contract = useTokenContract(tokenAddress)\n  const [data, setData] = useState(null)\n\n  useEffect(() => {\n    const getContractData = params => {\n      contract?.[method](...params)\n        .then(res => {\n          setData(res)\n        })\n        .catch(() => {\n          setData(null)\n        })\n    }\n\n    if (interval) {\n      getContractData(params)\n      const timeInterval = setInterval(() => getContractData(params), interval)\n      return () => clearInterval(timeInterval)\n    } else {\n      getContractData(params)\n    }\n  }, [...params, interval, Boolean(contract)])\n\n  return data\n}\n\nexport function useTokenBalance(tokenAddress, params) {\n  const balance = useContractState(\n    tokenAddress,\n    'balanceOf',\n    params,\n    IntervalTime.fetchBalance,\n  )\n  return balance ? new Big(balance) : BigNumZero\n}\n\nexport function useBalance(address, tokenAddress) {\n  const tokenBalance = useTokenBalance(tokenAddress, [address]) || BigNumZero\n  const nativeTokenBalance = useNativeTokenBalance(address) || BigNumZero\n  const isNativeToken = !checkHexAddress(tokenAddress)\n  return isNativeToken ? nativeTokenBalance : tokenBalance\n}\n"]},"metadata":{},"sourceType":"module"}
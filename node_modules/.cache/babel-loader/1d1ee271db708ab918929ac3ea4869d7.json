{"ast":null,"code":"// This was ported from https://github.com/MaiaVictor/eth-lib, with some minor\n// modifications to ESM module. It is licensed under MIT:\n//\n// Copyright 2017 Victor Maia\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nimport * as Bytes from '@cfxjs/bytes';\nimport * as Nat from '@cfxjs/nat';\nimport elliptic from 'elliptic';\nimport { keccak256, keccak256s } from '@cfxjs/keccak';\nimport { Buffer } from 'buffer';\nimport { randomInt } from '@cfxjs/utils';\nimport { NULL_HEX_ADDRESS, INTERNAL_CONTRACTS_HEX_ADDRESS, ADDRESS_TYPES } from '@cfxjs/fluent-wallet-consts';\nconst secp256k1 = elliptic.ec('secp256k1');\n\nconst create = entropy => {\n  const innerHex = keccak256(Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)));\n  const middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));\n  const outerHex = keccak256(middleHex);\n  return fromPrivate(outerHex);\n};\n\nconst toChecksum = address => {\n  const addressHash = keccak256s(address.slice(2));\n  let checksumAddress = '0x';\n\n  for (let i = 0; i < 40; i++) checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n\n  return checksumAddress;\n};\n\nconst fromPrivate = privateKey => {\n  const buffer = Buffer.from(privateKey.slice(2), 'hex');\n  const ecKey = secp256k1.keyFromPrivate(buffer);\n  const publicKey = '0x' + ecKey.getPublic(false, 'hex').slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum('0x' + publicHash.slice(-40));\n  return {\n    address: address,\n    privateKey: privateKey\n  };\n};\n\nconst encodeSignature = ([v, r, s]) => Bytes.flatten([r, s, v]);\n\nconst decodeSignature = hex => [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];\n\nconst makeSigner = addToV => (hash, privateKey) => {\n  const signature = secp256k1.keyFromPrivate(Buffer.from(privateKey.slice(2), 'hex')).sign(Buffer.from(hash.slice(2), 'hex'), {\n    canonical: true\n  });\n  return encodeSignature([Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat('0x' + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat('0x' + signature.s.toString(16)))]);\n};\n\nconst sign = makeSigner(27); // v=27|28 instead of 0|1...\n\nconst recover = (hash, signature) => {\n  const vals = decodeSignature(signature);\n  const vrs = {\n    v: Bytes.toNumber(vals[0]),\n    r: vals[1].slice(2),\n    s: vals[2].slice(2)\n  };\n  const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n\n  const publicKey = '0x' + ecPublicKey.encode('hex', false).slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum('0x' + publicHash.slice(-40));\n  return address;\n};\n\nexport const toAccountAddress = address => {\n  return address.replace(/^0x./, '0x1');\n};\nexport const toContractAddress = address => {\n  return address.replace(/^0x./, '0x8');\n};\nexport const randomHexAddress = (type, entropy) => {\n  if (type && !ADDRESS_TYPES.includes(type)) throw new Error(`Invalid address type ${type}`);\n  if (type === 'builtin') return INTERNAL_CONTRACTS_HEX_ADDRESS[randomInt(INTERNAL_CONTRACTS_HEX_ADDRESS.length)];\n  if (type === 'null') return NULL_HEX_ADDRESS;\n  const addr = create(entropy).address;\n  if (type === 'user') return toAccountAddress(addr);\n  if (type === 'contract') return toContractAddress(addr);\n  return addr;\n};\nexport const isHexAddress = address => /^0x[0-9a-fA-F]{40}$/.test(address);\nexport const isUserHexAddress = address => address.startsWith('0x1');\nexport const isContractAddress = address => address.startsWith('0x8');\nexport const isBuiltInAddress = address => INTERNAL_CONTRACTS_HEX_ADDRESS.includes(address.toLowerCase());\nexport const isNullHexAddress = address => address === NULL_HEX_ADDRESS;\nexport const isCfxHexAddress = address => isUserHexAddress(address) || isContractAddress(address) || isBuiltInAddress(address) || isNullHexAddress(address);\nexport const validateHexAddress = (address, type) => {\n  if (typeof address !== 'string') throw new Error('Invalid address, must be a 0x-prefixed string');\n  if (!address.startsWith('0x')) throw new Error('Invalid address, must be a 0x-prefixed string');\n  if (!isHexAddress(address)) return false;\n  if (type === 'eth') return true;\n  if (type === 'user') return isUserHexAddress(address);\n  if (type === 'contract') return isContractAddress(address);\n  if (type === 'builtin') return isBuiltInAddress(address);\n  if (type === 'null') return isNullHexAddress(address);\n  return isCfxHexAddress(address);\n};\nexport const randomAddressType = () => {\n  return ADDRESS_TYPES[randomInt(ADDRESS_TYPES.length)];\n};\nexport const randomCfxHexAddress = entropy => {\n  return randomHexAddress(randomAddressType(), entropy);\n};\nexport const randomPrivateKey = entropy => {\n  return create(entropy).privateKey;\n};\nexport const validatePrivateKey = privateKey => {\n  let valid = false;\n\n  try {\n    const rst = fromPrivate(privateKey);\n    valid = Boolean(rst.address);\n  } catch (err) {\n    valid = false;\n  }\n\n  return valid;\n};\nexport { create, toChecksum, fromPrivate, sign, makeSigner, recover, encodeSignature, decodeSignature };","map":{"version":3,"sources":["/Users/alice/Documents/rigel/node_modules/@cfxjs/account/index.js"],"names":["Bytes","Nat","elliptic","keccak256","keccak256s","Buffer","randomInt","NULL_HEX_ADDRESS","INTERNAL_CONTRACTS_HEX_ADDRESS","ADDRESS_TYPES","secp256k1","ec","create","entropy","innerHex","concat","random","middleHex","outerHex","fromPrivate","toChecksum","address","addressHash","slice","checksumAddress","i","parseInt","toUpperCase","privateKey","buffer","from","ecKey","keyFromPrivate","publicKey","getPublic","publicHash","encodeSignature","v","r","s","flatten","decodeSignature","hex","length","makeSigner","addToV","hash","signature","sign","canonical","fromString","fromNumber","recoveryParam","pad","fromNat","toString","recover","vals","vrs","toNumber","ecPublicKey","recoverPubKey","encode","toAccountAddress","replace","toContractAddress","randomHexAddress","type","includes","Error","addr","isHexAddress","test","isUserHexAddress","startsWith","isContractAddress","isBuiltInAddress","toLowerCase","isNullHexAddress","isCfxHexAddress","validateHexAddress","randomAddressType","randomCfxHexAddress","randomPrivateKey","validatePrivateKey","valid","rst","Boolean","err"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,KAAKA,KAAZ,MAAuB,cAAvB;AACA,OAAO,KAAKC,GAAZ,MAAqB,YAArB;AACA,OAAOC,QAAP,MAAqB,UAArB;AACA,SAAQC,SAAR,EAAmBC,UAAnB,QAAoC,eAApC;AACA,SAAQC,MAAR,QAAqB,QAArB;AACA,SAAQC,SAAR,QAAwB,cAAxB;AACA,SACEC,gBADF,EAEEC,8BAFF,EAGEC,aAHF,QAIO,6BAJP;AAMA,MAAMC,SAAS,GAAGR,QAAQ,CAACS,EAAT,CAAY,WAAZ,CAAlB;;AAEA,MAAMC,MAAM,GAAGC,OAAO,IAAI;AACxB,QAAMC,QAAQ,GAAGX,SAAS,CACxBH,KAAK,CAACe,MAAN,CAAaf,KAAK,CAACgB,MAAN,CAAa,EAAb,CAAb,EAA+BH,OAAO,IAAIb,KAAK,CAACgB,MAAN,CAAa,EAAb,CAA1C,CADwB,CAA1B;AAGA,QAAMC,SAAS,GAAGjB,KAAK,CAACe,MAAN,CAChBf,KAAK,CAACe,MAAN,CAAaf,KAAK,CAACgB,MAAN,CAAa,EAAb,CAAb,EAA+BF,QAA/B,CADgB,EAEhBd,KAAK,CAACgB,MAAN,CAAa,EAAb,CAFgB,CAAlB;AAIA,QAAME,QAAQ,GAAGf,SAAS,CAACc,SAAD,CAA1B;AACA,SAAOE,WAAW,CAACD,QAAD,CAAlB;AACD,CAVD;;AAYA,MAAME,UAAU,GAAGC,OAAO,IAAI;AAC5B,QAAMC,WAAW,GAAGlB,UAAU,CAACiB,OAAO,CAACE,KAAR,CAAc,CAAd,CAAD,CAA9B;AACA,MAAIC,eAAe,GAAG,IAAtB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EACED,eAAe,IACbE,QAAQ,CAACJ,WAAW,CAACG,CAAC,GAAG,CAAL,CAAZ,EAAqB,EAArB,CAAR,GAAmC,CAAnC,GACIJ,OAAO,CAACI,CAAC,GAAG,CAAL,CAAP,CAAeE,WAAf,EADJ,GAEIN,OAAO,CAACI,CAAC,GAAG,CAAL,CAHb;;AAIF,SAAOD,eAAP;AACD,CATD;;AAWA,MAAML,WAAW,GAAGS,UAAU,IAAI;AAChC,QAAMC,MAAM,GAAGxB,MAAM,CAACyB,IAAP,CAAYF,UAAU,CAACL,KAAX,CAAiB,CAAjB,CAAZ,EAAiC,KAAjC,CAAf;AACA,QAAMQ,KAAK,GAAGrB,SAAS,CAACsB,cAAV,CAAyBH,MAAzB,CAAd;AACA,QAAMI,SAAS,GAAG,OAAOF,KAAK,CAACG,SAAN,CAAgB,KAAhB,EAAuB,KAAvB,EAA8BX,KAA9B,CAAoC,CAApC,CAAzB;AACA,QAAMY,UAAU,GAAGhC,SAAS,CAAC8B,SAAD,CAA5B;AACA,QAAMZ,OAAO,GAAGD,UAAU,CAAC,OAAOe,UAAU,CAACZ,KAAX,CAAiB,CAAC,EAAlB,CAAR,CAA1B;AACA,SAAO;AACLF,IAAAA,OAAO,EAAEA,OADJ;AAELO,IAAAA,UAAU,EAAEA;AAFP,GAAP;AAID,CAVD;;AAYA,MAAMQ,eAAe,GAAG,CAAC,CAACC,CAAD,EAAIC,CAAJ,EAAOC,CAAP,CAAD,KAAevC,KAAK,CAACwC,OAAN,CAAc,CAACF,CAAD,EAAIC,CAAJ,EAAOF,CAAP,CAAd,CAAvC;;AAEA,MAAMI,eAAe,GAAGC,GAAG,IAAI,CAC7B1C,KAAK,CAACuB,KAAN,CAAY,EAAZ,EAAgBvB,KAAK,CAAC2C,MAAN,CAAaD,GAAb,CAAhB,EAAmCA,GAAnC,CAD6B,EAE7B1C,KAAK,CAACuB,KAAN,CAAY,CAAZ,EAAe,EAAf,EAAmBmB,GAAnB,CAF6B,EAG7B1C,KAAK,CAACuB,KAAN,CAAY,EAAZ,EAAgB,EAAhB,EAAoBmB,GAApB,CAH6B,CAA/B;;AAMA,MAAME,UAAU,GAAGC,MAAM,IAAI,CAACC,IAAD,EAAOlB,UAAP,KAAsB;AACjD,QAAMmB,SAAS,GAAGrC,SAAS,CACxBsB,cADe,CACA3B,MAAM,CAACyB,IAAP,CAAYF,UAAU,CAACL,KAAX,CAAiB,CAAjB,CAAZ,EAAiC,KAAjC,CADA,EAEfyB,IAFe,CAEV3C,MAAM,CAACyB,IAAP,CAAYgB,IAAI,CAACvB,KAAL,CAAW,CAAX,CAAZ,EAA2B,KAA3B,CAFU,EAEyB;AAAC0B,IAAAA,SAAS,EAAE;AAAZ,GAFzB,CAAlB;AAGA,SAAOb,eAAe,CAAC,CACrBnC,GAAG,CAACiD,UAAJ,CAAelD,KAAK,CAACmD,UAAN,CAAiBN,MAAM,GAAGE,SAAS,CAACK,aAApC,CAAf,CADqB,EAErBpD,KAAK,CAACqD,GAAN,CAAU,EAAV,EAAcrD,KAAK,CAACsD,OAAN,CAAc,OAAOP,SAAS,CAACT,CAAV,CAAYiB,QAAZ,CAAqB,EAArB,CAArB,CAAd,CAFqB,EAGrBvD,KAAK,CAACqD,GAAN,CAAU,EAAV,EAAcrD,KAAK,CAACsD,OAAN,CAAc,OAAOP,SAAS,CAACR,CAAV,CAAYgB,QAAZ,CAAqB,EAArB,CAArB,CAAd,CAHqB,CAAD,CAAtB;AAKD,CATD;;AAWA,MAAMP,IAAI,GAAGJ,UAAU,CAAC,EAAD,CAAvB,C,CAA4B;;AAE5B,MAAMY,OAAO,GAAG,CAACV,IAAD,EAAOC,SAAP,KAAqB;AACnC,QAAMU,IAAI,GAAGhB,eAAe,CAACM,SAAD,CAA5B;AACA,QAAMW,GAAG,GAAG;AACVrB,IAAAA,CAAC,EAAErC,KAAK,CAAC2D,QAAN,CAAeF,IAAI,CAAC,CAAD,CAAnB,CADO;AAEVnB,IAAAA,CAAC,EAAEmB,IAAI,CAAC,CAAD,CAAJ,CAAQlC,KAAR,CAAc,CAAd,CAFO;AAGVgB,IAAAA,CAAC,EAAEkB,IAAI,CAAC,CAAD,CAAJ,CAAQlC,KAAR,CAAc,CAAd;AAHO,GAAZ;AAKA,QAAMqC,WAAW,GAAGlD,SAAS,CAACmD,aAAV,CAClBxD,MAAM,CAACyB,IAAP,CAAYgB,IAAI,CAACvB,KAAL,CAAW,CAAX,CAAZ,EAA2B,KAA3B,CADkB,EAElBmC,GAFkB,EAGlBA,GAAG,CAACrB,CAAJ,GAAQ,CAAR,GAAYqB,GAAG,CAACrB,CAAhB,GAAoB,IAAKqB,GAAG,CAACrB,CAAJ,GAAQ,CAHf,CAApB,CAPmC,CAWjC;;AACF,QAAMJ,SAAS,GAAG,OAAO2B,WAAW,CAACE,MAAZ,CAAmB,KAAnB,EAA0B,KAA1B,EAAiCvC,KAAjC,CAAuC,CAAvC,CAAzB;AACA,QAAMY,UAAU,GAAGhC,SAAS,CAAC8B,SAAD,CAA5B;AACA,QAAMZ,OAAO,GAAGD,UAAU,CAAC,OAAOe,UAAU,CAACZ,KAAX,CAAiB,CAAC,EAAlB,CAAR,CAA1B;AACA,SAAOF,OAAP;AACD,CAhBD;;AAkBA,OAAO,MAAM0C,gBAAgB,GAAG1C,OAAO,IAAI;AACzC,SAAOA,OAAO,CAAC2C,OAAR,CAAgB,MAAhB,EAAwB,KAAxB,CAAP;AACD,CAFM;AAIP,OAAO,MAAMC,iBAAiB,GAAG5C,OAAO,IAAI;AAC1C,SAAOA,OAAO,CAAC2C,OAAR,CAAgB,MAAhB,EAAwB,KAAxB,CAAP;AACD,CAFM;AAIP,OAAO,MAAME,gBAAgB,GAAG,CAACC,IAAD,EAAOtD,OAAP,KAAmB;AACjD,MAAIsD,IAAI,IAAI,CAAC1D,aAAa,CAAC2D,QAAd,CAAuBD,IAAvB,CAAb,EACE,MAAM,IAAIE,KAAJ,CAAW,wBAAuBF,IAAK,EAAvC,CAAN;AACF,MAAIA,IAAI,KAAK,SAAb,EACE,OAAO3D,8BAA8B,CACnCF,SAAS,CAACE,8BAA8B,CAACmC,MAAhC,CAD0B,CAArC;AAGF,MAAIwB,IAAI,KAAK,MAAb,EAAqB,OAAO5D,gBAAP;AACrB,QAAM+D,IAAI,GAAG1D,MAAM,CAACC,OAAD,CAAN,CAAgBQ,OAA7B;AACA,MAAI8C,IAAI,KAAK,MAAb,EAAqB,OAAOJ,gBAAgB,CAACO,IAAD,CAAvB;AACrB,MAAIH,IAAI,KAAK,UAAb,EAAyB,OAAOF,iBAAiB,CAACK,IAAD,CAAxB;AACzB,SAAOA,IAAP;AACD,CAZM;AAcP,OAAO,MAAMC,YAAY,GAAGlD,OAAO,IAAI,sBAAsBmD,IAAtB,CAA2BnD,OAA3B,CAAhC;AACP,OAAO,MAAMoD,gBAAgB,GAAGpD,OAAO,IAAIA,OAAO,CAACqD,UAAR,CAAmB,KAAnB,CAApC;AACP,OAAO,MAAMC,iBAAiB,GAAGtD,OAAO,IAAIA,OAAO,CAACqD,UAAR,CAAmB,KAAnB,CAArC;AACP,OAAO,MAAME,gBAAgB,GAAGvD,OAAO,IACrCb,8BAA8B,CAAC4D,QAA/B,CAAwC/C,OAAO,CAACwD,WAAR,EAAxC,CADK;AAEP,OAAO,MAAMC,gBAAgB,GAAGzD,OAAO,IAAIA,OAAO,KAAKd,gBAAhD;AACP,OAAO,MAAMwE,eAAe,GAAG1D,OAAO,IACpCoD,gBAAgB,CAACpD,OAAD,CAAhB,IACAsD,iBAAiB,CAACtD,OAAD,CADjB,IAEAuD,gBAAgB,CAACvD,OAAD,CAFhB,IAGAyD,gBAAgB,CAACzD,OAAD,CAJX;AAMP,OAAO,MAAM2D,kBAAkB,GAAG,CAAC3D,OAAD,EAAU8C,IAAV,KAAmB;AACnD,MAAI,OAAO9C,OAAP,KAAmB,QAAvB,EACE,MAAM,IAAIgD,KAAJ,CAAU,+CAAV,CAAN;AACF,MAAI,CAAChD,OAAO,CAACqD,UAAR,CAAmB,IAAnB,CAAL,EACE,MAAM,IAAIL,KAAJ,CAAU,+CAAV,CAAN;AAEF,MAAI,CAACE,YAAY,CAAClD,OAAD,CAAjB,EAA4B,OAAO,KAAP;AAC5B,MAAI8C,IAAI,KAAK,KAAb,EAAoB,OAAO,IAAP;AACpB,MAAIA,IAAI,KAAK,MAAb,EAAqB,OAAOM,gBAAgB,CAACpD,OAAD,CAAvB;AACrB,MAAI8C,IAAI,KAAK,UAAb,EAAyB,OAAOQ,iBAAiB,CAACtD,OAAD,CAAxB;AACzB,MAAI8C,IAAI,KAAK,SAAb,EAAwB,OAAOS,gBAAgB,CAACvD,OAAD,CAAvB;AACxB,MAAI8C,IAAI,KAAK,MAAb,EAAqB,OAAOW,gBAAgB,CAACzD,OAAD,CAAvB;AACrB,SAAO0D,eAAe,CAAC1D,OAAD,CAAtB;AACD,CAbM;AAeP,OAAO,MAAM4D,iBAAiB,GAAG,MAAM;AACrC,SAAOxE,aAAa,CAACH,SAAS,CAACG,aAAa,CAACkC,MAAf,CAAV,CAApB;AACD,CAFM;AAIP,OAAO,MAAMuC,mBAAmB,GAAGrE,OAAO,IAAI;AAC5C,SAAOqD,gBAAgB,CAACe,iBAAiB,EAAlB,EAAsBpE,OAAtB,CAAvB;AACD,CAFM;AAIP,OAAO,MAAMsE,gBAAgB,GAAGtE,OAAO,IAAI;AACzC,SAAOD,MAAM,CAACC,OAAD,CAAN,CAAgBe,UAAvB;AACD,CAFM;AAIP,OAAO,MAAMwD,kBAAkB,GAAGxD,UAAU,IAAI;AAC9C,MAAIyD,KAAK,GAAG,KAAZ;;AACA,MAAI;AACF,UAAMC,GAAG,GAAGnE,WAAW,CAACS,UAAD,CAAvB;AACAyD,IAAAA,KAAK,GAAGE,OAAO,CAACD,GAAG,CAACjE,OAAL,CAAf;AACD,GAHD,CAGE,OAAOmE,GAAP,EAAY;AACZH,IAAAA,KAAK,GAAG,KAAR;AACD;;AAED,SAAOA,KAAP;AACD,CAVM;AAYP,SACEzE,MADF,EAEEQ,UAFF,EAGED,WAHF,EAIE6B,IAJF,EAKEJ,UALF,EAMEY,OANF,EAOEpB,eAPF,EAQEK,eARF","sourcesContent":["// This was ported from https://github.com/MaiaVictor/eth-lib, with some minor\n// modifications to ESM module. It is licensed under MIT:\n//\n// Copyright 2017 Victor Maia\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport * as Bytes from '@cfxjs/bytes'\nimport * as Nat from '@cfxjs/nat'\nimport elliptic from 'elliptic'\nimport {keccak256, keccak256s} from '@cfxjs/keccak'\nimport {Buffer} from 'buffer'\nimport {randomInt} from '@cfxjs/utils'\nimport {\n  NULL_HEX_ADDRESS,\n  INTERNAL_CONTRACTS_HEX_ADDRESS,\n  ADDRESS_TYPES,\n} from '@cfxjs/fluent-wallet-consts'\n\nconst secp256k1 = elliptic.ec('secp256k1')\n\nconst create = entropy => {\n  const innerHex = keccak256(\n    Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)),\n  )\n  const middleHex = Bytes.concat(\n    Bytes.concat(Bytes.random(32), innerHex),\n    Bytes.random(32),\n  )\n  const outerHex = keccak256(middleHex)\n  return fromPrivate(outerHex)\n}\n\nconst toChecksum = address => {\n  const addressHash = keccak256s(address.slice(2))\n  let checksumAddress = '0x'\n  for (let i = 0; i < 40; i++)\n    checksumAddress +=\n      parseInt(addressHash[i + 2], 16) > 7\n        ? address[i + 2].toUpperCase()\n        : address[i + 2]\n  return checksumAddress\n}\n\nconst fromPrivate = privateKey => {\n  const buffer = Buffer.from(privateKey.slice(2), 'hex')\n  const ecKey = secp256k1.keyFromPrivate(buffer)\n  const publicKey = '0x' + ecKey.getPublic(false, 'hex').slice(2)\n  const publicHash = keccak256(publicKey)\n  const address = toChecksum('0x' + publicHash.slice(-40))\n  return {\n    address: address,\n    privateKey: privateKey,\n  }\n}\n\nconst encodeSignature = ([v, r, s]) => Bytes.flatten([r, s, v])\n\nconst decodeSignature = hex => [\n  Bytes.slice(64, Bytes.length(hex), hex),\n  Bytes.slice(0, 32, hex),\n  Bytes.slice(32, 64, hex),\n]\n\nconst makeSigner = addToV => (hash, privateKey) => {\n  const signature = secp256k1\n    .keyFromPrivate(Buffer.from(privateKey.slice(2), 'hex'))\n    .sign(Buffer.from(hash.slice(2), 'hex'), {canonical: true})\n  return encodeSignature([\n    Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)),\n    Bytes.pad(32, Bytes.fromNat('0x' + signature.r.toString(16))),\n    Bytes.pad(32, Bytes.fromNat('0x' + signature.s.toString(16))),\n  ])\n}\n\nconst sign = makeSigner(27) // v=27|28 instead of 0|1...\n\nconst recover = (hash, signature) => {\n  const vals = decodeSignature(signature)\n  const vrs = {\n    v: Bytes.toNumber(vals[0]),\n    r: vals[1].slice(2),\n    s: vals[2].slice(2),\n  }\n  const ecPublicKey = secp256k1.recoverPubKey(\n    Buffer.from(hash.slice(2), 'hex'),\n    vrs,\n    vrs.v < 2 ? vrs.v : 1 - (vrs.v % 2),\n  ) // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n  const publicKey = '0x' + ecPublicKey.encode('hex', false).slice(2)\n  const publicHash = keccak256(publicKey)\n  const address = toChecksum('0x' + publicHash.slice(-40))\n  return address\n}\n\nexport const toAccountAddress = address => {\n  return address.replace(/^0x./, '0x1')\n}\n\nexport const toContractAddress = address => {\n  return address.replace(/^0x./, '0x8')\n}\n\nexport const randomHexAddress = (type, entropy) => {\n  if (type && !ADDRESS_TYPES.includes(type))\n    throw new Error(`Invalid address type ${type}`)\n  if (type === 'builtin')\n    return INTERNAL_CONTRACTS_HEX_ADDRESS[\n      randomInt(INTERNAL_CONTRACTS_HEX_ADDRESS.length)\n    ]\n  if (type === 'null') return NULL_HEX_ADDRESS\n  const addr = create(entropy).address\n  if (type === 'user') return toAccountAddress(addr)\n  if (type === 'contract') return toContractAddress(addr)\n  return addr\n}\n\nexport const isHexAddress = address => /^0x[0-9a-fA-F]{40}$/.test(address)\nexport const isUserHexAddress = address => address.startsWith('0x1')\nexport const isContractAddress = address => address.startsWith('0x8')\nexport const isBuiltInAddress = address =>\n  INTERNAL_CONTRACTS_HEX_ADDRESS.includes(address.toLowerCase())\nexport const isNullHexAddress = address => address === NULL_HEX_ADDRESS\nexport const isCfxHexAddress = address =>\n  isUserHexAddress(address) ||\n  isContractAddress(address) ||\n  isBuiltInAddress(address) ||\n  isNullHexAddress(address)\n\nexport const validateHexAddress = (address, type) => {\n  if (typeof address !== 'string')\n    throw new Error('Invalid address, must be a 0x-prefixed string')\n  if (!address.startsWith('0x'))\n    throw new Error('Invalid address, must be a 0x-prefixed string')\n\n  if (!isHexAddress(address)) return false\n  if (type === 'eth') return true\n  if (type === 'user') return isUserHexAddress(address)\n  if (type === 'contract') return isContractAddress(address)\n  if (type === 'builtin') return isBuiltInAddress(address)\n  if (type === 'null') return isNullHexAddress(address)\n  return isCfxHexAddress(address)\n}\n\nexport const randomAddressType = () => {\n  return ADDRESS_TYPES[randomInt(ADDRESS_TYPES.length)]\n}\n\nexport const randomCfxHexAddress = entropy => {\n  return randomHexAddress(randomAddressType(), entropy)\n}\n\nexport const randomPrivateKey = entropy => {\n  return create(entropy).privateKey\n}\n\nexport const validatePrivateKey = privateKey => {\n  let valid = false\n  try {\n    const rst = fromPrivate(privateKey)\n    valid = Boolean(rst.address)\n  } catch (err) {\n    valid = false\n  }\n\n  return valid\n}\n\nexport {\n  create,\n  toChecksum,\n  fromPrivate,\n  sign,\n  makeSigner,\n  recover,\n  encodeSignature,\n  decodeSignature,\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { AbstractConnector } from '@web3-react/abstract-connector';\nimport invariant from 'tiny-invariant';\n\nclass RequestError extends Error {\n  constructor(message) {\n    super(message);\n  }\n\n}\n\nclass MiniRpcProvider {\n  constructor(chainId, url, batchWaitTimeMs) {\n    this.nextId = 1;\n    this.chainId = chainId;\n    this.url = url;\n    const parsed = new URL(url);\n    this.host = parsed.host;\n    this.path = parsed.pathname;\n    this.batchTimeoutId = null;\n    this.batch = []; // how long to wait to batch calls\n\n    this.batchWaitTimeMs = batchWaitTimeMs !== null && batchWaitTimeMs !== void 0 ? batchWaitTimeMs : 50;\n  }\n\n  async clearBatch() {\n    console.debug('Clearing batch', this.batch);\n    const batch = this.batch;\n    this.batch = [];\n    this.batchTimeoutId = null;\n    let response;\n\n    try {\n      response = await fetch(this.url, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n          accept: 'application/json'\n        },\n        body: JSON.stringify(batch.map(item => item.request))\n      });\n    } catch (error) {\n      batch && batch.forEach(({\n        reject\n      }) => reject(new Error('Failed to send batch call')));\n      return;\n    }\n\n    if (!response.ok) {\n      batch.forEach(({\n        reject\n      }) => reject(new RequestError(`${response.status}: ${response.statusText}`, -32000)));\n      return;\n    }\n\n    let json;\n\n    try {\n      json = await response.json();\n    } catch (error) {\n      batch.forEach(({\n        reject\n      }) => reject(new Error('Failed to parse JSON response')));\n      return;\n    }\n\n    const byKey = batch.reduce((memo, current) => {\n      memo[current.request.id] = current;\n      return memo;\n    }, {});\n\n    for (const result of json) {\n      const {\n        resolve,\n        reject,\n        request: {\n          method\n        }\n      } = byKey[result.id];\n\n      if (resolve && reject) {\n        if ('error' in result) {\n          var _result$error, _result$error2, _result$error3;\n\n          reject(new RequestError(result === null || result === void 0 ? void 0 : (_result$error = result.error) === null || _result$error === void 0 ? void 0 : _result$error.message, result === null || result === void 0 ? void 0 : (_result$error2 = result.error) === null || _result$error2 === void 0 ? void 0 : _result$error2.code, result === null || result === void 0 ? void 0 : (_result$error3 = result.error) === null || _result$error3 === void 0 ? void 0 : _result$error3.data));\n        } else if ('result' in result) {\n          resolve(result.result);\n        } else {\n          reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result));\n        }\n      }\n    }\n  }\n\n  sendAsync(request, callback) {\n    this.request(request.method, request.params).then(result => callback(null, {\n      jsonrpc: '2.0',\n      id: request.id,\n      result\n    })).catch(error => callback(error, null));\n  }\n\n  async request(method, params) {\n    var _this$batchTimeoutId;\n\n    if (typeof method !== 'string') {\n      return this.request(method.method, method.params);\n    }\n\n    if (method === 'eth_chainId') {\n      return `0x${this.chainId.toString(16)}`;\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      this.batch.push({\n        request: {\n          jsonrpc: '2.0',\n          id: this.nextId++,\n          method,\n          params\n        },\n        resolve,\n        reject\n      });\n    });\n    this.batchTimeoutId = (_this$batchTimeoutId = this.batchTimeoutId) !== null && _this$batchTimeoutId !== void 0 ? _this$batchTimeoutId : setTimeout(this.clearBatch, this.batchWaitTimeMs);\n    return promise;\n  }\n\n}\n\nexport class NetworkConnector extends AbstractConnector {\n  constructor({\n    urls,\n    defaultChainId\n  }) {\n    invariant(defaultChainId || Object.keys(urls).length === 1, 'defaultChainId is a required argument with >1 url');\n    super({\n      supportedChainIds: Object.keys(urls).map(k => Number(k))\n    });\n    this.currentChainId = defaultChainId || Number(Object.keys(urls)[0]);\n    this.providers = Object.keys(urls).reduce((accumulator, chainId) => {\n      accumulator[Number(chainId)] = new MiniRpcProvider(Number(chainId), urls[Number(chainId)]);\n      return accumulator;\n    }, {});\n  }\n\n  get provider() {\n    return this.providers[this.currentChainId];\n  }\n\n  async activate() {\n    return {\n      provider: this.providers[this.currentChainId],\n      chainId: this.currentChainId,\n      account: null\n    };\n  }\n\n  async getProvider() {\n    return this.providers[this.currentChainId];\n  }\n\n  async getChainId() {\n    return this.currentChainId;\n  }\n\n  async getAccount() {\n    return null;\n  }\n\n  deactivate() {\n    return;\n  }\n\n}","map":{"version":3,"sources":["/Users/alice/Documents/rigel/src/utils/NetworkConnector.js"],"names":["AbstractConnector","invariant","RequestError","Error","constructor","message","MiniRpcProvider","chainId","url","batchWaitTimeMs","nextId","parsed","URL","host","path","pathname","batchTimeoutId","batch","clearBatch","console","debug","response","fetch","method","headers","accept","body","JSON","stringify","map","item","request","error","forEach","reject","ok","status","statusText","json","byKey","reduce","memo","current","id","result","resolve","code","data","sendAsync","callback","params","then","jsonrpc","catch","toString","promise","Promise","push","setTimeout","NetworkConnector","urls","defaultChainId","Object","keys","length","supportedChainIds","k","Number","currentChainId","providers","accumulator","provider","activate","account","getProvider","getChainId","getAccount","deactivate"],"mappings":"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","sourcesContent":["import {AbstractConnector} from '@web3-react/abstract-connector'\nimport invariant from 'tiny-invariant'\n\nclass RequestError extends Error {\n  constructor(message) {\n    super(message)\n  }\n}\n\nclass MiniRpcProvider {\n  constructor(chainId, url, batchWaitTimeMs) {\n    this.nextId = 1\n    this.chainId = chainId\n    this.url = url\n    const parsed = new URL(url)\n    this.host = parsed.host\n    this.path = parsed.pathname\n    this.batchTimeoutId = null\n    this.batch = []\n    // how long to wait to batch calls\n    this.batchWaitTimeMs = batchWaitTimeMs ?? 50\n  }\n\n  async clearBatch() {\n    console.debug('Clearing batch', this.batch)\n    const batch = this.batch\n    this.batch = []\n    this.batchTimeoutId = null\n    let response\n    try {\n      response = await fetch(this.url, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n          accept: 'application/json',\n        },\n        body: JSON.stringify(batch.map(item => item.request)),\n      })\n    } catch (error) {\n      batch &&\n        batch.forEach(({reject}) =>\n          reject(new Error('Failed to send batch call')),\n        )\n      return\n    }\n\n    if (!response.ok) {\n      batch.forEach(({reject}) =>\n        reject(\n          new RequestError(\n            `${response.status}: ${response.statusText}`,\n            -32000,\n          ),\n        ),\n      )\n      return\n    }\n\n    let json\n    try {\n      json = await response.json()\n    } catch (error) {\n      batch.forEach(({reject}) =>\n        reject(new Error('Failed to parse JSON response')),\n      )\n      return\n    }\n    const byKey = batch.reduce((memo, current) => {\n      memo[current.request.id] = current\n      return memo\n    }, {})\n    for (const result of json) {\n      const {\n        resolve,\n        reject,\n        request: {method},\n      } = byKey[result.id]\n      if (resolve && reject) {\n        if ('error' in result) {\n          reject(\n            new RequestError(\n              result?.error?.message,\n              result?.error?.code,\n              result?.error?.data,\n            ),\n          )\n        } else if ('result' in result) {\n          resolve(result.result)\n        } else {\n          reject(\n            new RequestError(\n              `Received unexpected JSON-RPC response to ${method} request.`,\n              -32000,\n              result,\n            ),\n          )\n        }\n      }\n    }\n  }\n\n  sendAsync(request, callback) {\n    this.request(request.method, request.params)\n      .then(result => callback(null, {jsonrpc: '2.0', id: request.id, result}))\n      .catch(error => callback(error, null))\n  }\n\n  async request(method, params) {\n    if (typeof method !== 'string') {\n      return this.request(method.method, method.params)\n    }\n    if (method === 'eth_chainId') {\n      return `0x${this.chainId.toString(16)}`\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.batch.push({\n        request: {\n          jsonrpc: '2.0',\n          id: this.nextId++,\n          method,\n          params,\n        },\n        resolve,\n        reject,\n      })\n    })\n    this.batchTimeoutId =\n      this.batchTimeoutId ?? setTimeout(this.clearBatch, this.batchWaitTimeMs)\n    return promise\n  }\n}\n\nexport class NetworkConnector extends AbstractConnector {\n  constructor({urls, defaultChainId}) {\n    invariant(\n      defaultChainId || Object.keys(urls).length === 1,\n      'defaultChainId is a required argument with >1 url',\n    )\n    super({supportedChainIds: Object.keys(urls).map(k => Number(k))})\n\n    this.currentChainId = defaultChainId || Number(Object.keys(urls)[0])\n    this.providers = Object.keys(urls).reduce((accumulator, chainId) => {\n      accumulator[Number(chainId)] = new MiniRpcProvider(\n        Number(chainId),\n        urls[Number(chainId)],\n      )\n      return accumulator\n    }, {})\n  }\n\n  get provider() {\n    return this.providers[this.currentChainId]\n  }\n\n  async activate() {\n    return {\n      provider: this.providers[this.currentChainId],\n      chainId: this.currentChainId,\n      account: null,\n    }\n  }\n\n  async getProvider() {\n    return this.providers[this.currentChainId]\n  }\n\n  async getChainId() {\n    return this.currentChainId\n  }\n\n  async getAccount() {\n    return null\n  }\n\n  deactivate() {\n    return\n  }\n}\n"]},"metadata":{},"sourceType":"module"}